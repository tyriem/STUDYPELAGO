function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var W3CWebSocket = require('websocket').w3cwebsocket;

var WebSocket = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(WebSocket, _React$Component);

  function WebSocket(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      ws: new W3CWebSocket(_this.props.url),
      attempts: 1
    };
    _this.sendMessage = _this.sendMessage.bind(_assertThisInitialized(_this));
    _this.setupWebsocket = _this.setupWebsocket.bind(_assertThisInitialized(_this));
    return _this;
  }

  var _proto = WebSocket.prototype;

  _proto.logging = function logging(logline) {
    if (this.props.debug === true) {
      console.log(logline);
    }
  };

  _proto.generateInterval = function generateInterval(k) {
    if (this.props.reconnectIntervalInMilliSeconds > 0) {
      return this.props.reconnectIntervalInMilliSeconds;
    }

    return Math.min(30, Math.pow(2, k) - 1) * 1000;
  };

  _proto.setupWebsocket = function setupWebsocket() {
    var _this2 = this;

    var websocket = this.state.ws;

    websocket.onopen = function () {
      _this2.logging('Websocket connected...');

      if (typeof _this2.props.onOpen === 'function') _this2.props.onOpen();
    };

    websocket.onerror = function (e) {
      if (typeof _this2.props.onError === 'function') _this2.props.onError(e);
    };

    websocket.onmessage = function (evt) {
      _this2.props.onMessage(evt.data);
    };

    this.shouldReconnect = this.props.reconnect;

    websocket.onclose = function (evt) {
      _this2.logging("Websocket disconnected,the reason: " + evt.reason + ",the code: " + evt.code);

      if (typeof _this2.props.onClose === 'function') _this2.props.onClose(evt.code, evt.reason);

      if (_this2.shouldReconnect) {
        var time = _this2.generateInterval(_this2.state.attempts);

        _this2.timeoutID = setTimeout(function () {
          _this2.setState({
            attempts: _this2.state.attempts + 1
          });

          _this2.setState({
            ws: new W3CWebSocket(_this2.props.url)
          });

          _this2.setupWebsocket();
        }, time);
      }
    };
  };

  _proto.componentDidMount = function componentDidMount() {
    var childRef = this.props.childRef;
    childRef && childRef(this);
    this.setupWebsocket();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    var childRef = this.props.childRef;
    childRef && childRef(undefined);
    this.shouldReconnect = false;
    clearTimeout(this.timeoutID);
    var websocket = this.state.ws;
    websocket.close();
  };

  _proto.sendMessage = function sendMessage(message) {
    var websocket = this.state.ws;
    websocket.send(message);
  };

  _proto.render = function render() {
    return /*#__PURE__*/React.createElement("div", null);
  };

  return WebSocket;
}(React.Component);

exports.WebSocket = WebSocket;
//# sourceMappingURL=index.js.map
