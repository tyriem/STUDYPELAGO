{"ast":null,"code":"import _slicedToArray from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */\n\nvar ExpirationPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  function ExpirationPlugin() {\n    var _this = this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ExpirationPlugin);\n\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n    this.cachedResponseWillBeUsed = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var event, request, cacheName, cachedResponse, isFresh, cacheExpiration, updateTimestampDone;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                event = _ref.event, request = _ref.request, cacheName = _ref.cacheName, cachedResponse = _ref.cachedResponse;\n\n                if (cachedResponse) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 3:\n                isFresh = _this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n                // expired, it'll only be used once.\n\n                cacheExpiration = _this._getCacheExpiration(cacheName);\n                dontWaitFor(cacheExpiration.expireEntries()); // Update the metadata for the request URL to the current timestamp,\n                // but don't `await` it as we don't want to block the response.\n\n                updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n                if (event) {\n                  try {\n                    event.waitUntil(updateTimestampDone);\n                  } catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                      // The event may not be a fetch event; only log the URL if it is.\n                      if ('request' in event) {\n                        logger.warn(\"Unable to ensure service worker stays alive when \" + \"updating cache entry for \" + \"'\".concat(getFriendlyURL(event.request.url), \"'.\"));\n                      }\n                    }\n                  }\n                }\n\n                return _context.abrupt(\"return\", isFresh ? cachedResponse : null);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n\n\n    this.cacheDidUpdate = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var cacheName, request, cacheExpiration;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheName = _ref3.cacheName, request = _ref3.request;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName'\n                  });\n                  assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request'\n                  });\n                }\n\n                cacheExpiration = _this._getCacheExpiration(cacheName);\n                _context2.next = 5;\n                return cacheExpiration.updateTimestamp(request.url);\n\n              case 5:\n                _context2.next = 7;\n                return cacheExpiration.expireEntries();\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(function () {\n        return _this.deleteCacheAndMetadata();\n      });\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n\n\n  _createClass(ExpirationPlugin, [{\n    key: \"_getCacheExpiration\",\n    value: function _getCacheExpiration(cacheName) {\n      if (cacheName === cacheNames.getRuntimeName()) {\n        throw new WorkboxError('expire-custom-caches-only');\n      }\n\n      var cacheExpiration = this._cacheExpirations.get(cacheName);\n\n      if (!cacheExpiration) {\n        cacheExpiration = new CacheExpiration(cacheName, this._config);\n\n        this._cacheExpirations.set(cacheName, cacheExpiration);\n      }\n\n      return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_isResponseDateFresh\",\n    value: function _isResponseDateFresh(cachedResponse) {\n      if (!this._maxAgeSeconds) {\n        // We aren't expiring by age, so return true, it's fresh\n        return true;\n      } // Check if the 'date' header will suffice a quick expiration check.\n      // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n      // discussion.\n\n\n      var dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n      if (dateHeaderTimestamp === null) {\n        // Unable to parse date, so assume it's fresh.\n        return true;\n      } // If we have a valid headerTime, then our response is fresh iff the\n      // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n      var now = Date.now();\n      return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getDateHeaderTimestamp\",\n    value: function _getDateHeaderTimestamp(cachedResponse) {\n      if (!cachedResponse.headers.has('date')) {\n        return null;\n      }\n\n      var dateHeader = cachedResponse.headers.get('date');\n      var parsedDate = new Date(dateHeader);\n      var headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n      // will return NaN.\n\n      if (isNaN(headerTime)) {\n        return null;\n      }\n\n      return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n\n  }, {\n    key: \"deleteCacheAndMetadata\",\n    value: function () {\n      var _deleteCacheAndMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _iterator, _step, _step$value, cacheName, cacheExpiration;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Do this one at a time instead of all at once via `Promise.all()` to\n                // reduce the chance of inconsistency if a promise rejects.\n                _iterator = _createForOfIteratorHelper(this._cacheExpirations);\n                _context3.prev = 1;\n\n                _iterator.s();\n\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _step$value = _slicedToArray(_step.value, 2), cacheName = _step$value[0], cacheExpiration = _step$value[1];\n                _context3.next = 7;\n                return self.caches.delete(cacheName);\n\n              case 7:\n                _context3.next = 9;\n                return cacheExpiration.delete();\n\n              case 9:\n                _context3.next = 3;\n                break;\n\n              case 11:\n                _context3.next = 16;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](1);\n\n                _iterator.e(_context3.t0);\n\n              case 16:\n                _context3.prev = 16;\n\n                _iterator.f();\n\n                return _context3.finish(16);\n\n              case 19:\n                // Reset this._cacheExpirations to its initial state.\n                this._cacheExpirations = new Map();\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 13, 16, 19]]);\n      }));\n\n      function deleteCacheAndMetadata() {\n        return _deleteCacheAndMetadata.apply(this, arguments);\n      }\n\n      return deleteCacheAndMetadata;\n    }()\n  }]);\n\n  return ExpirationPlugin;\n}();\n\nexport { ExpirationPlugin };","map":{"version":3,"sources":["/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/workbox-expiration/ExpirationPlugin.js"],"names":["assert","cacheNames","dontWaitFor","getFriendlyURL","logger","registerQuotaErrorCallback","WorkboxError","CacheExpiration","ExpirationPlugin","config","cachedResponseWillBeUsed","event","request","cacheName","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","expireEntries","updateTimestampDone","updateTimestamp","url","waitUntil","error","process","env","NODE_ENV","warn","cacheDidUpdate","isType","moduleName","className","funcName","paramName","isInstance","Request","maxEntries","maxAgeSeconds","_config","_maxAgeSeconds","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","getRuntimeName","get","set","dateHeaderTimestamp","_getDateHeaderTimestamp","now","Date","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","self","caches","delete"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in the Workbox APIs to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {Object} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n"]},"metadata":{},"sourceType":"module"}