{"ast":null,"code":"import _slicedToArray from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _assertThisInitialized from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _classCallCheck from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __rest } from 'tslib';\nimport { createBrowserHistory, createHashHistory } from 'history';\nimport React from 'react';\nimport { matchPath as matchPath$1, withRouter, Router } from 'react-router-dom';\nimport { ViewStacks, generateId, IonRoute, ViewLifeCycleManager, StackContext, RouteManagerContext, getConfig, LocationHistory, NavManager } from '@ionic/react';\nimport { Route, matchPath, Router as Router$1 } from 'react-router';\n\nvar IonRouteInner = /*#__PURE__*/function (_React$PureComponent) {\n  _inherits(IonRouteInner, _React$PureComponent);\n\n  var _super = _createSuper(IonRouteInner);\n\n  function IonRouteInner() {\n    _classCallCheck(this, IonRouteInner);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(IonRouteInner, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(Route, {\n        path: this.props.path,\n        exact: this.props.exact,\n        render: this.props.render,\n        computedMatch: this.props.computedMatch\n      });\n    }\n  }]);\n\n  return IonRouteInner;\n}(React.PureComponent);\n\nvar ReactRouterViewStack = /*#__PURE__*/function (_ViewStacks) {\n  _inherits(ReactRouterViewStack, _ViewStacks);\n\n  var _super2 = _createSuper(ReactRouterViewStack);\n\n  function ReactRouterViewStack() {\n    var _this;\n\n    _classCallCheck(this, ReactRouterViewStack);\n\n    _this = _super2.call(this);\n    _this.createViewItem = _this.createViewItem.bind(_assertThisInitialized(_this));\n    _this.findViewItemByRouteInfo = _this.findViewItemByRouteInfo.bind(_assertThisInitialized(_this));\n    _this.findLeavingViewItemByRouteInfo = _this.findLeavingViewItemByRouteInfo.bind(_assertThisInitialized(_this));\n    _this.getChildrenToRender = _this.getChildrenToRender.bind(_assertThisInitialized(_this));\n    _this.findViewItemByPathname = _this.findViewItemByPathname.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ReactRouterViewStack, [{\n    key: \"createViewItem\",\n    value: function createViewItem(outletId, reactElement, routeInfo, page) {\n      var viewItem = {\n        id: generateId('viewItem'),\n        outletId: outletId,\n        ionPageElement: page,\n        reactElement: reactElement,\n        mount: true,\n        ionRoute: false\n      };\n      var matchProps = {\n        exact: reactElement.props.exact,\n        path: reactElement.props.path || reactElement.props.from,\n        component: reactElement.props.component\n      };\n      var match = matchPath(routeInfo.pathname, matchProps);\n\n      if (reactElement.type === IonRoute) {\n        viewItem.ionRoute = true;\n        viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n      }\n\n      viewItem.routeData = {\n        match: match,\n        childProps: reactElement.props\n      };\n      return viewItem;\n    }\n  }, {\n    key: \"getChildrenToRender\",\n    value: function getChildrenToRender(outletId, ionRouterOutlet, routeInfo) {\n      var _this2 = this;\n\n      var viewItems = this.getViewItemsForOutlet(outletId); // Sync latest routes with viewItems\n\n      React.Children.forEach(ionRouterOutlet.props.children, function (child) {\n        var viewItem = viewItems.find(function (v) {\n          return matchComponent$1(child, v.routeData.childProps.path || v.routeData.childProps.from);\n        });\n\n        if (viewItem) {\n          viewItem.reactElement = child;\n        }\n      });\n      var children = viewItems.map(function (viewItem) {\n        var clonedChild;\n\n        if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n        } else {\n          var match = matchComponent$1(viewItem.reactElement, routeInfo.pathname);\n          clonedChild = React.createElement(ViewLifeCycleManager, {\n            key: \"view-\".concat(viewItem.id),\n            mount: viewItem.mount,\n            removeView: function removeView() {\n              return _this2.remove(viewItem);\n            }\n          }, React.cloneElement(viewItem.reactElement, {\n            computedMatch: viewItem.routeData.match\n          }));\n\n          if (!match && viewItem.routeData.match) {\n            viewItem.routeData.match = undefined;\n            viewItem.mount = false;\n          }\n        }\n\n        return clonedChild;\n      });\n      return children;\n    }\n  }, {\n    key: \"findViewItemByRouteInfo\",\n    value: function findViewItemByRouteInfo(routeInfo, outletId) {\n      var _this$findViewItemByP = this.findViewItemByPath(routeInfo.pathname, outletId),\n          viewItem = _this$findViewItemByP.viewItem,\n          match = _this$findViewItemByP.match;\n\n      if (viewItem && match) {\n        viewItem.routeData.match = match;\n      }\n\n      return viewItem;\n    }\n  }, {\n    key: \"findLeavingViewItemByRouteInfo\",\n    value: function findLeavingViewItemByRouteInfo(routeInfo, outletId) {\n      var mustBeIonRoute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var _this$findViewItemByP2 = this.findViewItemByPath(routeInfo.lastPathname, outletId, false, mustBeIonRoute),\n          viewItem = _this$findViewItemByP2.viewItem;\n\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPathname\",\n    value: function findViewItemByPathname(pathname, outletId) {\n      var _this$findViewItemByP3 = this.findViewItemByPath(pathname, outletId),\n          viewItem = _this$findViewItemByP3.viewItem;\n\n      return viewItem;\n    }\n  }, {\n    key: \"findViewItemByPath\",\n    value: function findViewItemByPath(pathname, outletId, forceExact, mustBeIonRoute) {\n      var viewItem;\n      var match;\n      var viewStack;\n\n      if (outletId) {\n        viewStack = this.getViewItemsForOutlet(outletId);\n        viewStack.some(matchView);\n\n        if (!viewItem) {\n          viewStack.some(matchDefaultRoute);\n        }\n      } else {\n        var viewItems = this.getAllViewItems();\n        viewItems.some(matchView);\n\n        if (!viewItem) {\n          viewItems.some(matchDefaultRoute);\n        }\n      }\n\n      return {\n        viewItem: viewItem,\n        match: match\n      };\n\n      function matchView(v) {\n        if (mustBeIonRoute && !v.ionRoute) {\n          return false;\n        }\n\n        var matchProps = {\n          exact: forceExact ? true : v.routeData.childProps.exact,\n          path: v.routeData.childProps.path || v.routeData.childProps.from,\n          component: v.routeData.childProps.component\n        };\n        var myMatch = matchPath(pathname, matchProps);\n\n        if (myMatch) {\n          viewItem = v;\n          match = myMatch;\n          return true;\n        }\n\n        return false;\n      }\n\n      function matchDefaultRoute(v) {\n        // try to find a route that doesn't have a path or from prop, that will be our default route\n        if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n          match = {\n            path: pathname,\n            url: pathname,\n            isExact: true,\n            params: {}\n          };\n          viewItem = v;\n          return true;\n        }\n\n        return false;\n      }\n    }\n  }]);\n\n  return ReactRouterViewStack;\n}(ViewStacks);\n\nfunction matchComponent$1(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath(pathname, matchProps);\n  return match;\n}\n\nfunction clonePageElement(leavingViewHtml) {\n  var html;\n\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n\n  if (document) {\n    var newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = ''; // Remove an existing back button so the new element doesn't get two of them\n\n    var ionBackButton = newEl.getElementsByTagName('ion-back-button');\n\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n\n    return newEl.firstChild;\n  }\n\n  return undefined;\n}\n\nvar StackManager = /*#__PURE__*/function (_React$PureComponent2) {\n  _inherits(StackManager, _React$PureComponent2);\n\n  var _super3 = _createSuper(StackManager);\n\n  function StackManager(props) {\n    var _this3;\n\n    _classCallCheck(this, StackManager);\n\n    _this3 = _super3.call(this, props);\n    _this3.stackContextValue = {\n      registerIonPage: _this3.registerIonPage.bind(_assertThisInitialized(_this3)),\n      isInOutlet: function isInOutlet() {\n        return true;\n      }\n    };\n    _this3.registerIonPage = _this3.registerIonPage.bind(_assertThisInitialized(_this3));\n    _this3.transitionPage = _this3.transitionPage.bind(_assertThisInitialized(_this3));\n    _this3.handlePageTransition = _this3.handlePageTransition.bind(_assertThisInitialized(_this3));\n    _this3.id = generateId('routerOutlet');\n    return _this3;\n  }\n\n  _createClass(StackManager, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.routerOutletElement) {\n        this.setupRouterOutlet(this.routerOutletElement); // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n\n        this.handlePageTransition(this.props.routeInfo);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n        this.handlePageTransition(this.props.routeInfo);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n      this.context.clearOutlet(this.id);\n    }\n  }, {\n    key: \"handlePageTransition\",\n    value: function () {\n      var _handlePageTransition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(routeInfo) {\n        var _this4 = this;\n\n        var _a, _b, enteringViewItem, leavingViewItem, enteringRoute;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // If routerOutlet isn't quite ready, give it another try in a moment\n                if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n                  setTimeout(function () {\n                    return _this4.handlePageTransition(routeInfo);\n                  }, 10);\n                } else {\n                  enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n                  leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n                  if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n                    leavingViewItem = this.context.findViewItemByPathname(routeInfo.prevRouteLastPathname, this.id);\n                  } // Check if leavingViewItem should be unmounted\n\n\n                  if (leavingViewItem) {\n                    if (routeInfo.routeAction === 'replace') {\n                      leavingViewItem.mount = false;\n                    } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n                      if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n                        leavingViewItem.mount = false;\n                      }\n                    } else if ((_a = routeInfo.routeOptions) === null || _a === void 0 ? void 0 : _a.unmount) {\n                      leavingViewItem.mount = false;\n                    }\n                  }\n\n                  enteringRoute = matchRoute((_b = this.ionRouterOutlet) === null || _b === void 0 ? void 0 : _b.props.children, routeInfo);\n\n                  if (enteringViewItem) {\n                    enteringViewItem.reactElement = enteringRoute;\n                  }\n\n                  if (!enteringViewItem) {\n                    if (enteringRoute) {\n                      enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n                      this.context.addViewItem(enteringViewItem);\n                    }\n                  }\n\n                  if (enteringViewItem && enteringViewItem.ionPageElement) {\n                    this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n                  } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n                    // If we have a leavingView but no entering view/route, we are probably leaving to\n                    // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n                    // transition to finish.\n                    // setTimeout(() => {\n                    if (leavingViewItem.ionPageElement) {\n                      leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                      leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                    } // }, 250);\n\n                  }\n\n                  this.forceUpdate();\n                }\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handlePageTransition(_x) {\n        return _handlePageTransition.apply(this, arguments);\n      }\n\n      return handlePageTransition;\n    }()\n  }, {\n    key: \"registerIonPage\",\n    value: function registerIonPage(page, routeInfo) {\n      var foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n\n      if (foundView) {\n        foundView.ionPageElement = page;\n        foundView.ionRoute = true;\n      }\n\n      this.handlePageTransition(routeInfo);\n    }\n  }, {\n    key: \"setupRouterOutlet\",\n    value: function () {\n      var _setupRouterOutlet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(routerOutlet) {\n        var _this5 = this;\n\n        var canStart, onStart;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                canStart = function canStart() {\n                  var config = getConfig();\n                  var swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n\n                  if (swipeEnabled) {\n                    return _this5.context.canGoBack();\n                  } else {\n                    return false;\n                  }\n                };\n\n                onStart = function onStart() {\n                  _this5.context.goBack();\n                };\n\n                routerOutlet.swipeHandler = {\n                  canStart: canStart,\n                  onStart: onStart,\n                  onEnd: function onEnd(_shouldContinue) {\n                    return true;\n                  }\n                };\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function setupRouterOutlet(_x2) {\n        return _setupRouterOutlet.apply(this, arguments);\n      }\n\n      return setupRouterOutlet;\n    }()\n  }, {\n    key: \"transitionPage\",\n    value: function () {\n      var _transitionPage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(routeInfo, enteringViewItem, leavingViewItem) {\n        var routerOutlet, direction, match, newLeavingElement, runCommit, _runCommit;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _runCommit = function _runCommit3() {\n                  _runCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(enteringEl, leavingEl) {\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            enteringEl.classList.add('ion-page');\n                            enteringEl.classList.add('ion-page-invisible');\n                            _context3.next = 4;\n                            return routerOutlet.commit(enteringEl, leavingEl, {\n                              deepWait: true,\n                              duration: direction === undefined ? 0 : undefined,\n                              direction: direction,\n                              showGoBack: !!routeInfo.pushedByRoute,\n                              progressAnimation: false,\n                              animationBuilder: routeInfo.routeAnimation\n                            });\n\n                          case 4:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n                  return _runCommit.apply(this, arguments);\n                };\n\n                runCommit = function _runCommit2(_x6, _x7) {\n                  return _runCommit.apply(this, arguments);\n                };\n\n                routerOutlet = this.routerOutletElement;\n                direction = routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root' ? undefined : routeInfo.routeDirection;\n\n                if (!(enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement)) {\n                  _context4.next = 23;\n                  break;\n                }\n\n                if (!(leavingViewItem && leavingViewItem.ionPageElement && enteringViewItem === leavingViewItem)) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                // If a page is transitioning to another version of itself\n                // we clone it so we can have an animation to show\n                match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n\n                if (!match) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n\n                if (!newLeavingElement) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                this.routerOutletElement.appendChild(newLeavingElement);\n                _context4.next = 13;\n                return runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n\n              case 13:\n                this.routerOutletElement.removeChild(newLeavingElement);\n\n              case 14:\n                _context4.next = 18;\n                break;\n\n              case 16:\n                _context4.next = 18;\n                return runCommit(enteringViewItem.ionPageElement, undefined);\n\n              case 18:\n                _context4.next = 23;\n                break;\n\n              case 20:\n                _context4.next = 22;\n                return runCommit(enteringViewItem.ionPageElement, leavingViewItem === null || leavingViewItem === void 0 ? void 0 : leavingViewItem.ionPageElement);\n\n              case 22:\n                if (leavingViewItem && leavingViewItem.ionPageElement) {\n                  leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n                  leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n                }\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function transitionPage(_x3, _x4, _x5) {\n        return _transitionPage.apply(this, arguments);\n      }\n\n      return transitionPage;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n\n      var children = this.props.children;\n      var ionRouterOutlet = React.Children.only(children);\n      this.ionRouterOutlet = ionRouterOutlet;\n      var components = this.context.getChildrenToRender(this.id, this.ionRouterOutlet, this.props.routeInfo, function () {\n        _this6.forceUpdate();\n      });\n      return React.createElement(StackContext.Provider, {\n        value: this.stackContextValue\n      }, React.cloneElement(ionRouterOutlet, {\n        ref: function ref(node) {\n          if (ionRouterOutlet.props.setRef) {\n            ionRouterOutlet.props.setRef(node);\n          }\n\n          if (ionRouterOutlet.props.forwardedRef) {\n            ionRouterOutlet.props.forwardedRef.current = node;\n          }\n\n          _this6.routerOutletElement = node;\n          var ref = ionRouterOutlet.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          }\n        }\n      }, components));\n    }\n  }], [{\n    key: \"contextType\",\n    get: function get() {\n      return RouteManagerContext;\n    }\n  }]);\n\n  return StackManager;\n}(React.PureComponent);\n\nfunction matchRoute(node, routeInfo) {\n  var matchedNode;\n  React.Children.forEach(node, function (child) {\n    var matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component\n    };\n    var match = matchPath$1(routeInfo.pathname, matchProps);\n\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  } // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n\n\n  React.Children.forEach(node, function (child) {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n  return matchedNode;\n}\n\nfunction matchComponent(node, pathname, forceExact) {\n  var matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component\n  };\n  var match = matchPath$1(pathname, matchProps);\n  return match;\n}\n\nvar IonRouterInner = /*#__PURE__*/function (_React$PureComponent3) {\n  _inherits(IonRouterInner, _React$PureComponent3);\n\n  var _super4 = _createSuper(IonRouterInner);\n\n  function IonRouterInner(props) {\n    var _this7;\n\n    _classCallCheck(this, IonRouterInner);\n\n    _this7 = _super4.call(this, props);\n    _this7.exitViewFromOtherOutletHandlers = [];\n    _this7.locationHistory = new LocationHistory();\n    _this7.viewStack = new ReactRouterViewStack();\n    _this7.routeMangerContextState = {\n      canGoBack: function canGoBack() {\n        return _this7.locationHistory.canGoBack();\n      },\n      clearOutlet: _this7.viewStack.clear,\n      findViewItemByPathname: _this7.viewStack.findViewItemByPathname,\n      getChildrenToRender: _this7.viewStack.getChildrenToRender,\n      goBack: function goBack() {\n        return _this7.handleNavigateBack();\n      },\n      createViewItem: _this7.viewStack.createViewItem,\n      findViewItemByRouteInfo: _this7.viewStack.findViewItemByRouteInfo,\n      findLeavingViewItemByRouteInfo: _this7.viewStack.findLeavingViewItemByRouteInfo,\n      addViewItem: _this7.viewStack.add,\n      unMountViewItem: _this7.viewStack.remove\n    };\n    var routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: _this7.props.location.pathname,\n      search: _this7.props.location.search\n    };\n\n    _this7.locationHistory.add(routeInfo);\n\n    _this7.handleChangeTab = _this7.handleChangeTab.bind(_assertThisInitialized(_this7));\n    _this7.handleResetTab = _this7.handleResetTab.bind(_assertThisInitialized(_this7));\n    _this7.handleNativeBack = _this7.handleNativeBack.bind(_assertThisInitialized(_this7));\n    _this7.handleNavigate = _this7.handleNavigate.bind(_assertThisInitialized(_this7));\n    _this7.handleNavigateBack = _this7.handleNavigateBack.bind(_assertThisInitialized(_this7));\n\n    _this7.props.registerHistoryListener(_this7.handleHistoryChange.bind(_assertThisInitialized(_this7)));\n\n    _this7.handleSetCurrentTab = _this7.handleSetCurrentTab.bind(_assertThisInitialized(_this7));\n    _this7.state = {\n      routeInfo: routeInfo\n    };\n    return _this7;\n  }\n\n  _createClass(IonRouterInner, [{\n    key: \"handleChangeTab\",\n    value: function handleChangeTab(tab, path, routeOptions) {\n      if (!path) {\n        return;\n      }\n\n      var routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n\n      var _path$split = path.split('?'),\n          _path$split2 = _slicedToArray(_path$split, 2),\n          pathname = _path$split2[0],\n          search = _path$split2[1];\n\n      if (routeInfo) {\n        this.incomingRouteParams = Object.assign(Object.assign({}, routeInfo), {\n          routeAction: 'push',\n          routeDirection: 'none'\n        });\n\n        if (routeInfo.pathname === pathname) {\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n        } else {\n          this.incomingRouteParams.pathname = pathname;\n          this.incomingRouteParams.search = search ? '?' + search : undefined;\n          this.incomingRouteParams.routeOptions = routeOptions;\n          this.props.history.push(pathname + (search ? '?' + search : ''));\n        }\n      } else {\n        this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n      }\n    }\n  }, {\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var _a, _b, _c;\n\n      var leavingLocationInfo;\n\n      if (this.incomingRouteParams) {\n        if (this.incomingRouteParams.routeAction === 'replace') {\n          leavingLocationInfo = this.locationHistory.previous();\n        } else {\n          leavingLocationInfo = this.locationHistory.current();\n        }\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n\n      var leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n\n      if (leavingUrl !== location.pathname) {\n        if (!this.incomingRouteParams) {\n          if (action === 'REPLACE') {\n            this.incomingRouteParams = {\n              routeAction: 'replace',\n              routeDirection: 'none',\n              tab: this.currentTab\n            };\n          }\n\n          if (action === 'POP') {\n            var currentRoute = this.locationHistory.current();\n\n            if (currentRoute && currentRoute.pushedByRoute) {\n              var prevInfo = this.locationHistory.findLastLocation(currentRoute);\n              this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n                routeAction: 'pop',\n                routeDirection: 'back'\n              });\n            } else {\n              this.incomingRouteParams = {\n                routeAction: 'pop',\n                routeDirection: 'none',\n                tab: this.currentTab\n              };\n            }\n          }\n\n          if (!this.incomingRouteParams) {\n            this.incomingRouteParams = {\n              routeAction: 'push',\n              routeDirection: ((_a = location.state) === null || _a === void 0 ? void 0 : _a.direction) || 'forward',\n              routeOptions: (_b = location.state) === null || _b === void 0 ? void 0 : _b.routerOptions,\n              tab: this.currentTab\n            };\n          }\n        }\n\n        var routeInfo;\n\n        if ((_c = this.incomingRouteParams) === null || _c === void 0 ? void 0 : _c.id) {\n          routeInfo = Object.assign(Object.assign({}, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname\n          });\n          this.locationHistory.add(routeInfo);\n        } else {\n          var isPushed = this.incomingRouteParams.routeAction === 'push' && this.incomingRouteParams.routeDirection === 'forward';\n          routeInfo = Object.assign(Object.assign({\n            id: generateId('routeInfo')\n          }, this.incomingRouteParams), {\n            lastPathname: leavingLocationInfo.pathname,\n            pathname: location.pathname,\n            search: location.search,\n            params: this.props.match.params,\n            prevRouteLastPathname: leavingLocationInfo.lastPathname\n          });\n\n          if (isPushed) {\n            routeInfo.tab = leavingLocationInfo.tab;\n            routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n          } else if (routeInfo.routeAction === 'pop') {\n            var r = this.locationHistory.findLastLocation(routeInfo);\n            routeInfo.pushedByRoute = r === null || r === void 0 ? void 0 : r.pushedByRoute;\n          } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n            // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n            var lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n            routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n          } else if (routeInfo.routeAction === 'replace') {\n            // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n            var currentRouteInfo = this.locationHistory.current();\n            /**\n             * If going from /home to /child, then replacing from\n             * /child to /home, we don't want the route info to\n             * say that /home was pushed by /home which is not correct.\n             */\n\n            var currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n            var pushedByRoute = currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname ? currentPushedBy : routeInfo.pushedByRoute;\n            routeInfo.lastPathname = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n            routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n            routeInfo.pushedByRoute = pushedByRoute;\n            routeInfo.routeDirection = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeDirection) || routeInfo.routeDirection;\n            routeInfo.routeAnimation = (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routeAnimation) || routeInfo.routeAnimation;\n          }\n\n          this.locationHistory.add(routeInfo);\n        }\n\n        this.setState({\n          routeInfo: routeInfo\n        });\n      }\n\n      this.incomingRouteParams = undefined;\n    }\n    /**\n     * history@4.x uses goBack(), history@5.x uses back()\n     * TODO: If support for React Router <=5 is dropped\n     * this logic is no longer needed. We can just\n     * assume back() is available.\n     */\n\n  }, {\n    key: \"handleNativeBack\",\n    value: function handleNativeBack() {\n      var history = this.props.history;\n      var goBack = history.goBack || history.back;\n      goBack();\n    }\n  }, {\n    key: \"handleNavigate\",\n    value: function handleNavigate(path, routeAction, routeDirection, routeAnimation, routeOptions, tab) {\n      this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n        routeAction: routeAction,\n        routeDirection: routeDirection,\n        routeOptions: routeOptions,\n        routeAnimation: routeAnimation,\n        tab: tab\n      });\n\n      if (routeAction === 'push') {\n        this.props.history.push(path);\n      } else {\n        this.props.history.replace(path);\n      }\n    }\n  }, {\n    key: \"handleNavigateBack\",\n    value: function handleNavigateBack() {\n      var defaultHref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n      var routeAnimation = arguments.length > 1 ? arguments[1] : undefined;\n      var config = getConfig();\n      defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref');\n      var routeInfo = this.locationHistory.current();\n\n      if (routeInfo && routeInfo.pushedByRoute) {\n        var prevInfo = this.locationHistory.findLastLocation(routeInfo);\n\n        if (prevInfo) {\n          this.incomingRouteParams = Object.assign(Object.assign({}, prevInfo), {\n            routeAction: 'pop',\n            routeDirection: 'back',\n            routeAnimation: routeAnimation || routeInfo.routeAnimation\n          });\n\n          if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          /**\n           * We need to exclude tab switches/tab\n           * context changes here because tabbed\n           * navigation is not linear, but router.back()\n           * will go back in a linear fashion.\n           */\n          prevInfo.pathname === routeInfo.pushedByRoute && routeInfo.tab === '' && prevInfo.tab === '') {\n            /**\n             * history@4.x uses goBack(), history@5.x uses back()\n             * TODO: If support for React Router <=5 is dropped\n             * this logic is no longer needed. We can just\n             * assume back() is available.\n             */\n            var history = this.props.history;\n            var goBack = history.goBack || history.back;\n            goBack();\n          } else {\n            this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n          }\n        } else {\n          this.handleNavigate(defaultHref, 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref, 'pop', 'back');\n      }\n    }\n  }, {\n    key: \"handleResetTab\",\n    value: function handleResetTab(tab, originalHref, originalRouteOptions) {\n      var routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n\n      if (routeInfo) {\n        var newRouteInfo = Object.assign({}, routeInfo);\n        newRouteInfo.pathname = originalHref;\n        newRouteInfo.routeOptions = originalRouteOptions;\n        this.incomingRouteParams = Object.assign(Object.assign({}, newRouteInfo), {\n          routeAction: 'pop',\n          routeDirection: 'back'\n        });\n        this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n      }\n    }\n  }, {\n    key: \"handleSetCurrentTab\",\n    value: function handleSetCurrentTab(tab) {\n      this.currentTab = tab;\n      var ri = Object.assign({}, this.locationHistory.current());\n\n      if (ri.tab !== tab) {\n        ri.tab = tab;\n        this.locationHistory.update(ri);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(RouteManagerContext.Provider, {\n        value: this.routeMangerContextState\n      }, React.createElement(NavManager, {\n        ionRoute: IonRouteInner,\n        ionRedirect: {},\n        stackManager: StackManager,\n        routeInfo: this.state.routeInfo,\n        onNativeBack: this.handleNativeBack,\n        onNavigateBack: this.handleNavigateBack,\n        onNavigate: this.handleNavigate,\n        onSetCurrentTab: this.handleSetCurrentTab,\n        onChangeTab: this.handleChangeTab,\n        onResetTab: this.handleResetTab,\n        locationHistory: this.locationHistory\n      }, this.props.children));\n    }\n  }]);\n\n  return IonRouterInner;\n}(React.PureComponent);\n\nvar IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n\nvar IonReactRouter = /*#__PURE__*/function (_React$Component) {\n  _inherits(IonReactRouter, _React$Component);\n\n  var _super5 = _createSuper(IonReactRouter);\n\n  function IonReactRouter(props) {\n    var _this8;\n\n    _classCallCheck(this, IonReactRouter);\n\n    _this8 = _super5.call(this, props);\n\n    var history = props.history,\n        rest = __rest(props, [\"history\"]);\n\n    _this8.history = history || createBrowserHistory(rest);\n\n    _this8.history.listen(_this8.handleHistoryChange.bind(_assertThisInitialized(_this8)));\n\n    _this8.registerHistoryListener = _this8.registerHistoryListener.bind(_assertThisInitialized(_this8));\n    return _this8;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactRouter;\n}(React.Component);\n\nvar IonReactMemoryRouter = /*#__PURE__*/function (_React$Component2) {\n  _inherits(IonReactMemoryRouter, _React$Component2);\n\n  var _super6 = _createSuper(IonReactMemoryRouter);\n\n  function IonReactMemoryRouter(props) {\n    var _this9;\n\n    _classCallCheck(this, IonReactMemoryRouter);\n\n    _this9 = _super6.call(this, props);\n    _this9.history = props.history;\n\n    _this9.history.listen(_this9.handleHistoryChange.bind(_assertThisInitialized(_this9)));\n\n    _this9.registerHistoryListener = _this9.registerHistoryListener.bind(_assertThisInitialized(_this9));\n    return _this9;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactMemoryRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router$1, Object.assign({}, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactMemoryRouter;\n}(React.Component);\n\nvar IonReactHashRouter = /*#__PURE__*/function (_React$Component3) {\n  _inherits(IonReactHashRouter, _React$Component3);\n\n  var _super7 = _createSuper(IonReactHashRouter);\n\n  function IonReactHashRouter(props) {\n    var _this10;\n\n    _classCallCheck(this, IonReactHashRouter);\n\n    _this10 = _super7.call(this, props);\n\n    var history = props.history,\n        rest = __rest(props, [\"history\"]);\n\n    _this10.history = history || createHashHistory(rest);\n\n    _this10.history.listen(_this10.handleHistoryChange.bind(_assertThisInitialized(_this10)));\n\n    _this10.registerHistoryListener = _this10.registerHistoryListener.bind(_assertThisInitialized(_this10));\n    return _this10;\n  }\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n\n\n  _createClass(IonReactHashRouter, [{\n    key: \"handleHistoryChange\",\n    value: function handleHistoryChange(location, action) {\n      var locationValue = location.location || location;\n      var actionValue = location.action || action;\n\n      if (this.historyListenHandler) {\n        this.historyListenHandler(locationValue, actionValue);\n      }\n    }\n  }, {\n    key: \"registerHistoryListener\",\n    value: function registerHistoryListener(cb) {\n      this.historyListenHandler = cb;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _a = this.props,\n          children = _a.children,\n          props = __rest(_a, [\"children\"]);\n\n      return React.createElement(Router, Object.assign({\n        history: this.history\n      }, props), React.createElement(IonRouter, {\n        registerHistoryListener: this.registerHistoryListener\n      }, children));\n    }\n  }]);\n\n  return IonReactHashRouter;\n}(React.Component);\n\nexport { IonReactHashRouter, IonReactMemoryRouter, IonReactRouter };","map":{"version":3,"sources":["../src/ReactRouter/IonRouteInner.tsx","../src/ReactRouter/ReactRouterViewStack.tsx","../src/ReactRouter/clonePageElement.ts","../src/ReactRouter/StackManager.tsx","../src/ReactRouter/IonRouter.tsx","../src/ReactRouter/IonReactRouter.tsx","../src/ReactRouter/IonReactMemoryRouter.tsx","../src/ReactRouter/IonReactHashRouter.tsx"],"names":["matchComponent","matchPath","createHistory","Router"],"mappings":";;;;;;;;;;;;;;;IAIa,a;;;;;;;;;;;;;WACX,kBAAM;AACJ,aACE,KAAA,CAAA,aAAA,CAAC,KAAD,EAAM;AACJ,QAAA,IAAI,EAAE,KAAK,KAAL,CAAW,IADb;AAEJ,QAAA,KAAK,EAAE,KAAK,KAAL,CAAW,KAFd;AAGJ,QAAA,MAAM,EAAE,KAAK,KAAL,CAAW,MAHf;AAIJ,QAAA,aAAa,EAAG,KAAK,KAAL,CAAmB;AAJ/B,OAAN,CADF;AAQD;;;;EAVgC,KAAK,CAAC,a;;ICO5B,oB;;;;;AACX,kCAAA;AAAA;;AAAA;;AACE;AACA,UAAK,cAAL,GAAsB,MAAK,cAAL,CAAoB,IAApB,+BAAtB;AACA,UAAK,uBAAL,GAA+B,MAAK,uBAAL,CAA6B,IAA7B,+BAA/B;AACA,UAAK,8BAAL,GAAsC,MAAK,8BAAL,CAAoC,IAApC,+BAAtC;AACA,UAAK,mBAAL,GAA2B,MAAK,mBAAL,CAAyB,IAAzB,+BAA3B;AACA,UAAK,sBAAL,GAA8B,MAAK,sBAAL,CAA4B,IAA5B,+BAA9B;AANF;AAOC;;;;WAED,wBACE,QADF,EAEE,YAFF,EAGE,SAHF,EAIE,IAJF,EAIoB;AAElB,UAAM,QAAQ,GAAa;AACzB,QAAA,EAAE,EAAE,UAAU,CAAC,UAAD,CADW;AAEzB,QAAA,QAAQ,EAAR,QAFyB;AAGzB,QAAA,cAAc,EAAE,IAHS;AAIzB,QAAA,YAAY,EAAZ,YAJyB;AAKzB,QAAA,KAAK,EAAE,IALkB;AAMzB,QAAA,QAAQ,EAAE;AANe,OAA3B;AASA,UAAM,UAAU,GAAG;AACjB,QAAA,KAAK,EAAE,YAAY,CAAC,KAAb,CAAmB,KADT;AAEjB,QAAA,IAAI,EAAE,YAAY,CAAC,KAAb,CAAmB,IAAnB,IAA2B,YAAY,CAAC,KAAb,CAAmB,IAFnC;AAGjB,QAAA,SAAS,EAAE,YAAY,CAAC,KAAb,CAAmB;AAHb,OAAnB;AAMA,UAAM,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,QAAX,EAAqB,UAArB,CAAvB;;AAEA,UAAI,YAAY,CAAC,IAAb,KAAsB,QAA1B,EAAoC;AAClC,QAAA,QAAQ,CAAC,QAAT,GAAoB,IAApB;AACA,QAAA,QAAQ,CAAC,wBAAT,GAAoC,YAAY,CAAC,KAAb,CAAmB,wBAAvD;AACD;;AAED,MAAA,QAAQ,CAAC,SAAT,GAAqB;AACnB,QAAA,KAAK,EAAL,KADmB;AAEnB,QAAA,UAAU,EAAE,YAAY,CAAC;AAFN,OAArB;AAKA,aAAO,QAAP;AACD;;;WAED,6BAAoB,QAApB,EAAsC,eAAtC,EAA2E,SAA3E,EAA+F;AAAA;;AAC7F,UAAM,SAAS,GAAG,KAAK,qBAAL,CAA2B,QAA3B,CAAlB,CAD6F,C;;AAI7F,MAAA,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,eAAe,CAAC,KAAhB,CAAsB,QAA7C,EAAuD,UAAC,KAAD,EAA0B;AAC/E,YAAM,QAAQ,GAAG,SAAS,CAAC,IAAV,CAAe,UAAC,CAAD,EAAE;AAChC,iBAAOA,gBAAc,CAAC,KAAD,EAAQ,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAAvB,IAA+B,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAA9D,CAArB;AACD,SAFgB,CAAjB;;AAGA,YAAI,QAAJ,EAAc;AACZ,UAAA,QAAQ,CAAC,YAAT,GAAwB,KAAxB;AACD;AACF,OAPD;AASA,UAAM,QAAQ,GAAG,SAAS,CAAC,GAAV,CAAc,UAAC,QAAD,EAAS;AACtC,YAAI,WAAJ;;AACA,YAAI,QAAQ,CAAC,QAAT,IAAqB,CAAC,QAAQ,CAAC,wBAAnC,EAA6D;AAC3D,UAAA,WAAW,GACT,KAAA,CAAA,aAAA,CAAC,oBAAD,EAAqB;AACnB,YAAA,GAAG,iBAAU,QAAQ,CAAC,EAAnB,CADgB;AAEnB,YAAA,KAAK,EAAE,QAAQ,CAAC,KAFG;AAGnB,YAAA,UAAU,EAAE;AAAA,qBAAM,MAAI,CAAC,MAAL,CAAY,QAAZ,CAAN;AAAA;AAHO,WAArB,EAKG,KAAK,CAAC,YAAN,CAAmB,QAAQ,CAAC,YAA5B,EAA0C;AACzC,YAAA,aAAa,EAAE,QAAQ,CAAC,SAAT,CAAmB;AADO,WAA1C,CALH,CADF;AAWD,SAZD,MAYO;AACL,cAAM,KAAK,GAAGA,gBAAc,CAAC,QAAQ,CAAC,YAAV,EAAwB,SAAS,CAAC,QAAlC,CAA5B;AACA,UAAA,WAAW,GACT,KAAA,CAAA,aAAA,CAAC,oBAAD,EAAqB;AACnB,YAAA,GAAG,iBAAU,QAAQ,CAAC,EAAnB,CADgB;AAEnB,YAAA,KAAK,EAAE,QAAQ,CAAC,KAFG;AAGnB,YAAA,UAAU,EAAE;AAAA,qBAAM,MAAI,CAAC,MAAL,CAAY,QAAZ,CAAN;AAAA;AAHO,WAArB,EAKG,KAAK,CAAC,YAAN,CAAmB,QAAQ,CAAC,YAA5B,EAA0C;AACzC,YAAA,aAAa,EAAE,QAAQ,CAAC,SAAT,CAAmB;AADO,WAA1C,CALH,CADF;;AAYA,cAAI,CAAC,KAAD,IAAU,QAAQ,CAAC,SAAT,CAAmB,KAAjC,EAAwC;AACtC,YAAA,QAAQ,CAAC,SAAT,CAAmB,KAAnB,GAA2B,SAA3B;AACA,YAAA,QAAQ,CAAC,KAAT,GAAiB,KAAjB;AACD;AACF;;AAED,eAAO,WAAP;AACD,OAnCgB,CAAjB;AAoCA,aAAO,QAAP;AACD;;;WAED,iCAAwB,SAAxB,EAA8C,QAA9C,EAA+D;AAC7D,kCAA4B,KAAK,kBAAL,CAAwB,SAAS,CAAC,QAAlC,EAA4C,QAA5C,CAA5B;AAAA,UAAQ,QAAR,yBAAQ,QAAR;AAAA,UAAkB,KAAlB,yBAAkB,KAAlB;;AACA,UAAI,QAAQ,IAAI,KAAhB,EAAuB;AACrB,QAAA,QAAQ,CAAC,SAAT,CAAmB,KAAnB,GAA2B,KAA3B;AACD;;AACD,aAAO,QAAP;AACD;;;WAED,wCAA+B,SAA/B,EAAqD,QAArD,EAA6F;AAAA,UAArB,cAAqB,uEAAJ,IAAI;;AAC3F,mCAAqB,KAAK,kBAAL,CACnB,SAAS,CAAC,YADS,EAEnB,QAFmB,EAGnB,KAHmB,EAInB,cAJmB,CAArB;AAAA,UAAQ,QAAR,0BAAQ,QAAR;;AAMA,aAAO,QAAP;AACD;;;WAED,gCAAuB,QAAvB,EAAyC,QAAzC,EAA0D;AACxD,mCAAqB,KAAK,kBAAL,CAAwB,QAAxB,EAAkC,QAAlC,CAArB;AAAA,UAAQ,QAAR,0BAAQ,QAAR;;AACA,aAAO,QAAP;AACD;;;WAEO,4BACN,QADM,EAEN,QAFM,EAGN,UAHM,EAIN,cAJM,EAIkB;AAExB,UAAI,QAAJ;AACA,UAAI,KAAJ;AACA,UAAI,SAAJ;;AAEA,UAAI,QAAJ,EAAc;AACZ,QAAA,SAAS,GAAG,KAAK,qBAAL,CAA2B,QAA3B,CAAZ;AACA,QAAA,SAAS,CAAC,IAAV,CAAe,SAAf;;AACA,YAAI,CAAC,QAAL,EAAe;AACb,UAAA,SAAS,CAAC,IAAV,CAAe,iBAAf;AACD;AACF,OAND,MAMO;AACL,YAAM,SAAS,GAAG,KAAK,eAAL,EAAlB;AACA,QAAA,SAAS,CAAC,IAAV,CAAe,SAAf;;AACA,YAAI,CAAC,QAAL,EAAe;AACb,UAAA,SAAS,CAAC,IAAV,CAAe,iBAAf;AACD;AACF;;AAED,aAAO;AAAE,QAAA,QAAQ,EAAR,QAAF;AAAY,QAAA,KAAK,EAAL;AAAZ,OAAP;;AAEA,eAAS,SAAT,CAAmB,CAAnB,EAA8B;AAC5B,YAAI,cAAc,IAAI,CAAC,CAAC,CAAC,QAAzB,EAAmC;AACjC,iBAAO,KAAP;AACD;;AACD,YAAM,UAAU,GAAG;AACjB,UAAA,KAAK,EAAE,UAAU,GAAG,IAAH,GAAU,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,KADjC;AAEjB,UAAA,IAAI,EAAE,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAAvB,IAA+B,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAF3C;AAGjB,UAAA,SAAS,EAAE,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB;AAHjB,SAAnB;AAKA,YAAM,OAAO,GAAG,SAAS,CAAC,QAAD,EAAW,UAAX,CAAzB;;AACA,YAAI,OAAJ,EAAa;AACX,UAAA,QAAQ,GAAG,CAAX;AACA,UAAA,KAAK,GAAG,OAAR;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD;;AAED,eAAS,iBAAT,CAA2B,CAA3B,EAAsC;;AAEpC,YAAI,CAAC,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAAxB,IAAgC,CAAC,CAAC,CAAC,SAAF,CAAY,UAAZ,CAAuB,IAA5D,EAAkE;AAChE,UAAA,KAAK,GAAG;AACN,YAAA,IAAI,EAAE,QADA;AAEN,YAAA,GAAG,EAAE,QAFC;AAGN,YAAA,OAAO,EAAE,IAHH;AAIN,YAAA,MAAM,EAAE;AAJF,WAAR;AAMA,UAAA,QAAQ,GAAG,CAAX;AACA,iBAAO,IAAP;AACD;;AACD,eAAO,KAAP;AACD;AACF;;;;EAnLuC,U;;AAsL1C,SAASA,gBAAT,CAAwB,IAAxB,EAAkD,QAAlD,EAAoE,UAApE,EAAwF;AACtF,MAAM,UAAU,GAAG;AACjB,IAAA,KAAK,EAAE,UAAU,GAAG,IAAH,GAAU,IAAI,CAAC,KAAL,CAAW,KADrB;AAEjB,IAAA,IAAI,EAAE,IAAI,CAAC,KAAL,CAAW,IAAX,IAAmB,IAAI,CAAC,KAAL,CAAW,IAFnB;AAGjB,IAAA,SAAS,EAAE,IAAI,CAAC,KAAL,CAAW;AAHL,GAAnB;AAKA,MAAM,KAAK,GAAG,SAAS,CAAC,QAAD,EAAW,UAAX,CAAvB;AAEA,SAAO,KAAP;AACF;;SC1MgB,gB,CAAiB,e,EAAqC;AACpE,MAAI,IAAJ;;AACA,MAAI,OAAO,eAAP,KAA2B,QAA/B,EAAyC;AACvC,IAAA,IAAI,GAAG,eAAP;AACD,GAFD,MAEO;AACL,IAAA,IAAI,GAAG,eAAe,CAAC,SAAvB;AACD;;AACD,MAAI,QAAJ,EAAc;AACZ,QAAM,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAd;AACA,IAAA,KAAK,CAAC,SAAN,GAAkB,IAAlB;AACA,IAAA,KAAK,CAAC,KAAN,CAAY,MAAZ,GAAqB,EAArB,CAHY,C;;AAKZ,QAAM,aAAa,GAAG,KAAK,CAAC,oBAAN,CAA2B,iBAA3B,CAAtB;;AACA,QAAI,aAAa,CAAC,CAAD,CAAjB,EAAsB;AACpB,MAAA,aAAa,CAAC,CAAD,CAAb,CAAiB,MAAjB;AACD;;AACD,WAAO,KAAK,CAAC,UAAb;AACD;;AACD,SAAO,SAAP;AACF;;ICCa,Y;;;;;AAWX,wBAAY,KAAZ,EAAoC;AAAA;;AAAA;;AAClC,gCAAM,KAAN;AANF,WAAA,iBAAA,GAAuC;AACrC,MAAA,eAAe,EAAE,OAAK,eAAL,CAAqB,IAArB,gCADoB;AAErC,MAAA,UAAU,EAAE;AAAA,eAAM,IAAN;AAAA;AAFyB,KAAvC;AAOE,WAAK,eAAL,GAAuB,OAAK,eAAL,CAAqB,IAArB,gCAAvB;AACA,WAAK,cAAL,GAAsB,OAAK,cAAL,CAAoB,IAApB,gCAAtB;AACA,WAAK,oBAAL,GAA4B,OAAK,oBAAL,CAA0B,IAA1B,gCAA5B;AACA,WAAK,EAAL,GAAU,UAAU,CAAC,cAAD,CAApB;AALkC;AAMnC;;;;WAED,6BAAiB;AACf,UAAI,KAAK,mBAAT,EAA8B;AAC5B,aAAK,iBAAL,CAAuB,KAAK,mBAA5B,EAD4B,C;;AAG5B,aAAK,oBAAL,CAA0B,KAAK,KAAL,CAAW,SAArC;AACD;AACF;;;WAED,4BAAmB,SAAnB,EAA+C;AAC7C,UAAI,KAAK,KAAL,CAAW,SAAX,CAAqB,QAArB,KAAkC,SAAS,CAAC,SAAV,CAAoB,QAA1D,EAAoE;AAClE,aAAK,oBAAL,CAA0B,KAAK,KAAL,CAAW,SAArC;AACD;AACF;;;WAED,gCAAoB;;AAElB,WAAK,OAAL,CAAa,WAAb,CAAyB,KAAK,EAA9B;AACD;;;;2FAED,iBAA2B,SAA3B;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEE,oBAAI,CAAC,KAAK,mBAAN,IAA6B,CAAC,KAAK,mBAAL,CAAyB,MAA3D,EAAmE;AACjE,kBAAA,UAAU,CAAC;AAAA,2BAAM,MAAI,CAAC,oBAAL,CAA0B,SAA1B,CAAN;AAAA,mBAAD,EAA6C,EAA7C,CAAV;AACD,iBAFD,MAEO;AACD,kBAAA,gBADC,GACkB,KAAK,OAAL,CAAa,uBAAb,CAAqC,SAArC,EAAgD,KAAK,EAArD,CADlB;AAED,kBAAA,eAFC,GAEiB,KAAK,OAAL,CAAa,8BAAb,CAA4C,SAA5C,EAAuD,KAAK,EAA5D,CAFjB;;AAIL,sBAAI,CAAC,eAAD,IAAoB,SAAS,CAAC,qBAAlC,EAAyD;AACvD,oBAAA,eAAe,GAAG,KAAK,OAAL,CAAa,sBAAb,CAChB,SAAS,CAAC,qBADM,EAEhB,KAAK,EAFW,CAAlB;AAID,mBATI,C;;;AAYL,sBAAI,eAAJ,EAAqB;AACnB,wBAAI,SAAS,CAAC,WAAV,KAA0B,SAA9B,EAAyC;AACvC,sBAAA,eAAe,CAAC,KAAhB,GAAwB,KAAxB;AACD,qBAFD,MAEO,IAAI,EAAE,SAAS,CAAC,WAAV,KAA0B,MAA1B,IAAoC,SAAS,CAAC,cAAV,KAA6B,SAAnE,CAAJ,EAAmF;AACxF,0BAAI,SAAS,CAAC,cAAV,KAA6B,MAA7B,IAAuC,gBAAgB,KAAK,eAAhE,EAAiF;AAC/E,wBAAA,eAAe,CAAC,KAAhB,GAAwB,KAAxB;AACD;AACF,qBAJM,MAIA,IAAA,CAAA,EAAA,GAAI,SAAS,CAAC,YAAd,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,KAAA,CAA1B,GAA0B,EAAA,CAAE,OAA5B,EAAqC;AAC1C,sBAAA,eAAe,CAAC,KAAhB,GAAwB,KAAxB;AACD;AACF;;AAEK,kBAAA,aAxBD,GAwBiB,UAAU,CAAA,CAAA,EAAA,GAC9B,KAAK,eADyB,MACV,IADU,IACV,EAAA,KAAA,KAAA,CADU,GACV,KAAA,CADU,GACV,EAAA,CAAE,KAAF,CAAQ,QADE,EAE9B,SAF8B,CAxB3B;;AA4BL,sBAAI,gBAAJ,EAAsB;AACpB,oBAAA,gBAAgB,CAAC,YAAjB,GAAgC,aAAhC;AACD;;AACD,sBAAI,CAAC,gBAAL,EAAuB;AACrB,wBAAI,aAAJ,EAAmB;AACjB,sBAAA,gBAAgB,GAAG,KAAK,OAAL,CAAa,cAAb,CAA4B,KAAK,EAAjC,EAAqC,aAArC,EAAoD,SAApD,CAAnB;AACA,2BAAK,OAAL,CAAa,WAAb,CAAyB,gBAAzB;AACD;AACF;;AACD,sBAAI,gBAAgB,IAAI,gBAAgB,CAAC,cAAzC,EAAyD;AACvD,yBAAK,cAAL,CAAoB,SAApB,EAA+B,gBAA/B,EAAiD,eAAjD;AACD,mBAFD,MAEO,IAAI,eAAe,IAAI,CAAC,aAApB,IAAqC,CAAC,gBAA1C,EAA4D;;;;;AAKjE,wBAAI,eAAe,CAAC,cAApB,EAAoC;AAClC,sBAAA,eAAe,CAAC,cAAhB,CAA+B,SAA/B,CAAyC,GAAzC,CAA6C,iBAA7C;AACA,sBAAA,eAAe,CAAC,cAAhB,CAA+B,YAA/B,CAA4C,aAA5C,EAA2D,MAA3D;AACD,qBARgE,C;;AAUlE;;AAED,uBAAK,WAAL;AACD;;AAxDH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WA2DA,yBAAgB,IAAhB,EAAmC,SAAnC,EAAuD;AACrD,UAAM,SAAS,GAAG,KAAK,OAAL,CAAa,uBAAb,CAAqC,SAArC,EAAgD,KAAK,EAArD,CAAlB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,SAAS,CAAC,cAAV,GAA2B,IAA3B;AACA,QAAA,SAAS,CAAC,QAAV,GAAqB,IAArB;AACD;;AACD,WAAK,oBAAL,CAA0B,SAA1B;AACD;;;;wFAED,kBAAwB,YAAxB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACQ,gBAAA,QADR,GACmB,SAAX,QAAW,GAAA;AACf,sBAAM,MAAM,GAAG,SAAS,EAAxB;AACA,sBAAM,YAAY,GAAG,MAAM,IAAI,MAAM,CAAC,GAAP,CAAW,kBAAX,EAA+B,YAAY,CAAC,IAAb,KAAsB,KAArD,CAA/B;;AACA,sBAAI,YAAJ,EAAkB;AAChB,2BAAO,MAAI,CAAC,OAAL,CAAa,SAAb,EAAP;AACD,mBAFD,MAEO;AACL,2BAAO,KAAP;AACD;AACF,iBATH;;AAWQ,gBAAA,OAXR,GAWkB,SAAV,OAAU,GAAA;AACd,kBAAA,MAAI,CAAC,OAAL,CAAa,MAAb;AACD,iBAbH;;AAcE,gBAAA,YAAY,CAAC,YAAb,GAA4B;AAC1B,kBAAA,QAAQ,EAAR,QAD0B;AAE1B,kBAAA,OAAO,EAAP,OAF0B;AAG1B,kBAAA,KAAK,EAAE,eAAC,eAAD;AAAA,2BAAqB,IAArB;AAAA;AAHmB,iBAA5B;;AAdF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;qFAqBA,kBACE,SADF,EAEE,gBAFF,EAGE,eAHF;AAAA,+DAyCiB,SAzCjB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wFAyCE,kBAAyB,UAAzB,EAAkD,SAAlD;AAAA;AAAA;AAAA;AAAA;AACE,4BAAA,UAAU,CAAC,SAAX,CAAqB,GAArB,CAAyB,UAAzB;AACA,4BAAA,UAAU,CAAC,SAAX,CAAqB,GAArB,CAAyB,oBAAzB;AAFF;AAAA,mCAIQ,YAAY,CAAC,MAAb,CAAoB,UAApB,EAAgC,SAAhC,EAA2C;AAC/C,8BAAA,QAAQ,EAAE,IADqC;AAE/C,8BAAA,QAAQ,EAAE,SAAS,KAAK,SAAd,GAA0B,CAA1B,GAA8B,SAFO;AAG/C,8BAAA,SAAS,EAAE,SAHoC;AAI/C,8BAAA,UAAU,EAAE,CAAC,CAAC,SAAS,CAAC,aAJuB;AAK/C,8BAAA,iBAAiB,EAAE,KAL4B;AAM/C,8BAAA,gBAAgB,EAAE,SAAS,CAAC;AANmB,6BAA3C,CAJR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAzCF;AAAA;AAAA;;AAyCiB,gBAAA,SAzCjB;AAAA;AAAA;;AAKQ,gBAAA,YALR,GAKuB,KAAK,mBAL5B;AAOQ,gBAAA,SAPR,GAQI,SAAS,CAAC,cAAV,KAA6B,MAA7B,IAAuC,SAAS,CAAC,cAAV,KAA6B,MAApE,GACI,SADJ,GAEI,SAAS,CAAC,cAVlB;;AAAA,sBAYM,gBAAgB,IAAI,gBAAgB,CAAC,cAArC,IAAuD,KAAK,mBAZlE;AAAA;AAAA;AAAA;;AAAA,sBAcM,eAAe,IACf,eAAe,CAAC,cADhB,IAEA,gBAAgB,KAAK,eAhB3B;AAAA;AAAA;AAAA;;;;AAqBY,gBAAA,KArBZ,GAqBoB,cAAc,CAAC,eAAe,CAAC,YAAjB,EAA+B,SAAS,CAAC,QAAzC,EAAmD,IAAnD,CArBlC;;AAAA,qBAsBU,KAtBV;AAAA;AAAA;AAAA;;AAuBc,gBAAA,iBAvBd,GAuBkC,gBAAgB,CAAC,eAAe,CAAC,cAAhB,CAA+B,SAAhC,CAvBlD;;AAAA,qBAwBY,iBAxBZ;AAAA;AAAA;AAAA;;AAyBU,qBAAK,mBAAL,CAAyB,WAAzB,CAAqC,iBAArC;AAzBV;AAAA,uBA0BgB,SAAS,CAAC,gBAAgB,CAAC,cAAlB,EAAkC,iBAAlC,CA1BzB;;AAAA;AA2BU,qBAAK,mBAAL,CAAyB,WAAzB,CAAqC,iBAArC;;AA3BV;AAAA;AAAA;;AAAA;AAAA;AAAA,uBA8Bc,SAAS,CAAC,gBAAgB,CAAC,cAAlB,EAAkC,SAAlC,CA9BvB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,uBAiCY,SAAS,CAAC,gBAAgB,CAAC,cAAlB,EAAkC,eAAe,KAAA,IAAf,IAAA,eAAe,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAA,eAAe,CAAE,cAAnD,CAjCrB;;AAAA;AAkCM,oBAAI,eAAe,IAAI,eAAe,CAAC,cAAvC,EAAuD;AACrD,kBAAA,eAAe,CAAC,cAAhB,CAA+B,SAA/B,CAAyC,GAAzC,CAA6C,iBAA7C;AACA,kBAAA,eAAe,CAAC,cAAhB,CAA+B,YAA/B,CAA4C,aAA5C,EAA2D,MAA3D;AACD;;AArCP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAwDA,kBAAM;AAAA;;AACJ,UAAQ,QAAR,GAAqB,KAAK,KAA1B,CAAQ,QAAR;AACA,UAAM,eAAe,GAAG,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,QAApB,CAAxB;AACA,WAAK,eAAL,GAAuB,eAAvB;AAEA,UAAM,UAAU,GAAG,KAAK,OAAL,CAAa,mBAAb,CACjB,KAAK,EADY,EAEjB,KAAK,eAFY,EAGjB,KAAK,KAAL,CAAW,SAHM,EAIjB,YAAA;AACE,QAAA,MAAI,CAAC,WAAL;AACD,OANgB,CAAnB;AASA,aACE,KAAA,CAAA,aAAA,CAAC,YAAY,CAAC,QAAd,EAAsB;AAAC,QAAA,KAAK,EAAE,KAAK;AAAb,OAAtB,EACG,KAAK,CAAC,YAAN,CACC,eADD,EAEC;AACE,QAAA,GAAG,EAAE,aAAC,IAAD,EAAiC;AACpC,cAAI,eAAe,CAAC,KAAhB,CAAsB,MAA1B,EAAkC;AAChC,YAAA,eAAe,CAAC,KAAhB,CAAsB,MAAtB,CAA6B,IAA7B;AACD;;AACD,cAAI,eAAe,CAAC,KAAhB,CAAsB,YAA1B,EAAwC;AACtC,YAAA,eAAe,CAAC,KAAhB,CAAsB,YAAtB,CAAmC,OAAnC,GAA6C,IAA7C;AACD;;AACD,UAAA,MAAI,CAAC,mBAAL,GAA2B,IAA3B;AACA,cAAQ,GAAR,GAAgB,eAAhB,CAAQ,GAAR;;AACA,cAAI,OAAO,GAAP,KAAe,UAAnB,EAA+B;AAC7B,YAAA,GAAG,CAAC,IAAD,CAAH;AACD;AACF;AAbH,OAFD,EAiBC,UAjBD,CADH,CADF;AAuBD;;;SAED,eAAsB;AACpB,aAAO,mBAAP;AACD;;;;EAhO+B,KAAK,CAAC,a;;AAqOxC,SAAS,UAAT,CAAoB,IAApB,EAA2C,SAA3C,EAA+D;AAC7D,MAAI,WAAJ;AACA,EAAA,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,IAAvB,EAAmD,UAAC,KAAD,EAA0B;AAC3E,QAAM,UAAU,GAAG;AACjB,MAAA,KAAK,EAAE,KAAK,CAAC,KAAN,CAAY,KADF;AAEjB,MAAA,IAAI,EAAE,KAAK,CAAC,KAAN,CAAY,IAAZ,IAAoB,KAAK,CAAC,KAAN,CAAY,IAFrB;AAGjB,MAAA,SAAS,EAAE,KAAK,CAAC,KAAN,CAAY;AAHN,KAAnB;AAKA,QAAM,KAAK,GAAGC,WAAS,CAAC,SAAS,CAAC,QAAX,EAAqB,UAArB,CAAvB;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,WAAW,GAAG,KAAd;AACD;AACF,GAVD;;AAYA,MAAI,WAAJ,EAAiB;AACf,WAAO,WAAP;AACD,GAhB4D,C;;;;AAmB7D,EAAA,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,IAAvB,EAAmD,UAAC,KAAD,EAA0B;AAC3E,QAAI,EAAE,KAAK,CAAC,KAAN,CAAY,IAAZ,IAAoB,KAAK,CAAC,KAAN,CAAY,IAAlC,CAAJ,EAA6C;AAC3C,MAAA,WAAW,GAAG,KAAd;AACD;AACF,GAJD;AAMA,SAAO,WAAP;AACD;;AAED,SAAS,cAAT,CAAwB,IAAxB,EAAkD,QAAlD,EAAoE,UAApE,EAAwF;AACtF,MAAM,UAAU,GAAG;AACjB,IAAA,KAAK,EAAE,UAAU,GAAG,IAAH,GAAU,IAAI,CAAC,KAAL,CAAW,KADrB;AAEjB,IAAA,IAAI,EAAE,IAAI,CAAC,KAAL,CAAW,IAAX,IAAmB,IAAI,CAAC,KAAL,CAAW,IAFnB;AAGjB,IAAA,SAAS,EAAE,IAAI,CAAC,KAAL,CAAW;AAHL,GAAnB;AAKA,MAAM,KAAK,GAAGA,WAAS,CAAC,QAAD,EAAW,UAAX,CAAvB;AAEA,SAAO,KAAP;AACF;;IC1PM,c;;;;;AAmBJ,0BAAY,KAAZ,EAAgC;AAAA;;AAAA;;AAC9B,gCAAM,KAAN;AAlBF,WAAA,+BAAA,GAAkF,EAAlF;AAEA,WAAA,eAAA,GAAkB,IAAI,eAAJ,EAAlB;AACA,WAAA,SAAA,GAAY,IAAI,oBAAJ,EAAZ;AACA,WAAA,uBAAA,GAAoD;AAClD,MAAA,SAAS,EAAE;AAAA,eAAM,OAAK,eAAL,CAAqB,SAArB,EAAN;AAAA,OADuC;AAElD,MAAA,WAAW,EAAE,OAAK,SAAL,CAAe,KAFsB;AAGlD,MAAA,sBAAsB,EAAE,OAAK,SAAL,CAAe,sBAHW;AAIlD,MAAA,mBAAmB,EAAE,OAAK,SAAL,CAAe,mBAJc;AAKlD,MAAA,MAAM,EAAE;AAAA,eAAM,OAAK,kBAAL,EAAN;AAAA,OAL0C;AAMlD,MAAA,cAAc,EAAE,OAAK,SAAL,CAAe,cANmB;AAOlD,MAAA,uBAAuB,EAAE,OAAK,SAAL,CAAe,uBAPU;AAQlD,MAAA,8BAA8B,EAAE,OAAK,SAAL,CAAe,8BARG;AASlD,MAAA,WAAW,EAAE,OAAK,SAAL,CAAe,GATsB;AAUlD,MAAA,eAAe,EAAE,OAAK,SAAL,CAAe;AAVkB,KAApD;AAgBE,QAAM,SAAS,GAAG;AAChB,MAAA,EAAE,EAAE,UAAU,CAAC,WAAD,CADE;AAEhB,MAAA,QAAQ,EAAE,OAAK,KAAL,CAAW,QAAX,CAAoB,QAFd;AAGhB,MAAA,MAAM,EAAE,OAAK,KAAL,CAAW,QAAX,CAAoB;AAHZ,KAAlB;;AAMA,WAAK,eAAL,CAAqB,GAArB,CAAyB,SAAzB;;AACA,WAAK,eAAL,GAAuB,OAAK,eAAL,CAAqB,IAArB,gCAAvB;AACA,WAAK,cAAL,GAAsB,OAAK,cAAL,CAAoB,IAApB,gCAAtB;AACA,WAAK,gBAAL,GAAwB,OAAK,gBAAL,CAAsB,IAAtB,gCAAxB;AACA,WAAK,cAAL,GAAsB,OAAK,cAAL,CAAoB,IAApB,gCAAtB;AACA,WAAK,kBAAL,GAA0B,OAAK,kBAAL,CAAwB,IAAxB,gCAA1B;;AACA,WAAK,KAAL,CAAW,uBAAX,CAAmC,OAAK,mBAAL,CAAyB,IAAzB,gCAAnC;;AACA,WAAK,mBAAL,GAA2B,OAAK,mBAAL,CAAyB,IAAzB,gCAA3B;AAEA,WAAK,KAAL,GAAa;AACX,MAAA,SAAS,EAAT;AADW,KAAb;AAlB8B;AAqB/B;;;;WAED,yBAAgB,GAAhB,EAA6B,IAA7B,EAA4C,YAA5C,EAA8D;AAC5D,UAAI,CAAC,IAAL,EAAW;AAAE;AAAS;;AAEtB,UAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,yBAArB,CAA+C,GAA/C,CAAlB;;AACA,wBAA2B,IAAI,CAAC,KAAL,CAAW,GAAX,CAA3B;AAAA;AAAA,UAAO,QAAP;AAAA,UAAiB,MAAjB;;AACA,UAAI,SAAJ,EAAe;AACb,aAAK,mBAAL,GAAwB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,SAAR,CAAA,EAAiB;AAAE,UAAA,WAAW,EAAE,MAAf;AAAuB,UAAA,cAAc,EAAE;AAAvC,SAAjB,CAAxB;;AACA,YAAI,SAAS,CAAC,QAAV,KAAuB,QAA3B,EAAqC;AACnC,eAAK,mBAAL,CAAyB,YAAzB,GAAwC,YAAxC;AACA,eAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,CAAwB,SAAS,CAAC,QAAV,IAAsB,SAAS,CAAC,MAAV,IAAoB,EAA1C,CAAxB;AACD,SAHD,MAGO;AACL,eAAK,mBAAL,CAAyB,QAAzB,GAAoC,QAApC;AACA,eAAK,mBAAL,CAAyB,MAAzB,GAAkC,MAAM,GAAG,MAAM,MAAT,GAAkB,SAA1D;AACA,eAAK,mBAAL,CAAyB,YAAzB,GAAwC,YAAxC;AACA,eAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,CAAwB,QAAQ,IAAI,MAAM,GAAG,MAAM,MAAT,GAAkB,EAA5B,CAAhC;AACD;AACF,OAXD,MAWO;AACL,aAAK,cAAL,CAAoB,QAApB,EAA8B,MAA9B,EAAsC,MAAtC,EAA8C,SAA9C,EAAyD,YAAzD,EAAuE,GAAvE;AACD;AACF;;;WAED,6BAAoB,QAApB,EAA8D,MAA9D,EAAmF;;;AACjF,UAAI,mBAAJ;;AACA,UAAI,KAAK,mBAAT,EAA8B;AAC5B,YAAI,KAAK,mBAAL,CAAyB,WAAzB,KAAyC,SAA7C,EAAwD;AACtD,UAAA,mBAAmB,GAAG,KAAK,eAAL,CAAqB,QAArB,EAAtB;AACD,SAFD,MAEO;AACL,UAAA,mBAAmB,GAAG,KAAK,eAAL,CAAqB,OAArB,EAAtB;AACD;AACF,OAND,MAMO;AACL,QAAA,mBAAmB,GAAG,KAAK,eAAL,CAAqB,OAArB,EAAtB;AACD;;AAED,UAAM,UAAU,GAAG,mBAAmB,CAAC,QAApB,GAA+B,mBAAmB,CAAC,MAAtE;;AACA,UAAI,UAAU,KAAK,QAAQ,CAAC,QAA5B,EAAsC;AACpC,YAAI,CAAC,KAAK,mBAAV,EAA+B;AAC7B,cAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,iBAAK,mBAAL,GAA2B;AACzB,cAAA,WAAW,EAAE,SADY;AAEzB,cAAA,cAAc,EAAE,MAFS;AAGzB,cAAA,GAAG,EAAE,KAAK;AAHe,aAA3B;AAKD;;AACD,cAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,gBAAM,YAAY,GAAG,KAAK,eAAL,CAAqB,OAArB,EAArB;;AACA,gBAAI,YAAY,IAAI,YAAY,CAAC,aAAjC,EAAgD;AAC9C,kBAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,gBAArB,CAAsC,YAAtC,CAAjB;AACA,mBAAK,mBAAL,GAAwB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,QAAR,CAAA,EAAgB;AAAE,gBAAA,WAAW,EAAE,KAAf;AAAsB,gBAAA,cAAc,EAAE;AAAtC,eAAhB,CAAxB;AACD,aAHD,MAGO;AACL,mBAAK,mBAAL,GAA2B;AACzB,gBAAA,WAAW,EAAE,KADY;AAEzB,gBAAA,cAAc,EAAE,MAFS;AAGzB,gBAAA,GAAG,EAAE,KAAK;AAHe,eAA3B;AAKD;AACF;;AACD,cAAI,CAAC,KAAK,mBAAV,EAA+B;AAC7B,iBAAK,mBAAL,GAA2B;AACzB,cAAA,WAAW,EAAE,MADY;AAEzB,cAAA,cAAc,EAAE,CAAA,CAAA,EAAA,GAAA,QAAQ,CAAC,KAAT,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,SAAhB,KAA6B,SAFpB;AAGzB,cAAA,YAAY,EAAA,CAAA,EAAA,GAAE,QAAQ,CAAC,KAAX,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAE,aAHL;AAIzB,cAAA,GAAG,EAAE,KAAK;AAJe,aAA3B;AAMD;AACF;;AAED,YAAI,SAAJ;;AAEA,YAAA,CAAA,EAAA,GAAI,KAAK,mBAAT,MAA4B,IAA5B,IAA4B,EAAA,KAAA,KAAA,CAA5B,GAA4B,KAAA,CAA5B,GAA4B,EAAA,CAAE,EAA9B,EAAkC;AAChC,UAAA,SAAS,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACH,KAAK,mBADF,CAAA,EACmC;AAC1C,YAAA,YAAY,EAAE,mBAAmB,CAAC;AADQ,WADnC,CAAT;AAIA,eAAK,eAAL,CAAqB,GAArB,CAAyB,SAAzB;AACD,SAND,MAMO;AACL,cAAM,QAAQ,GACZ,KAAK,mBAAL,CAAyB,WAAzB,KAAyC,MAAzC,IACA,KAAK,mBAAL,CAAyB,cAAzB,KAA4C,SAF9C;AAGA,UAAA,SAAS,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA;AACP,YAAA,EAAE,EAAE,UAAU,CAAC,WAAD;AADP,WAAA,EAEJ,KAAK,mBAFD,CAAA,EAEoB;AAC3B,YAAA,YAAY,EAAE,mBAAmB,CAAC,QADP;AAE3B,YAAA,QAAQ,EAAE,QAAQ,CAAC,QAFQ;AAG3B,YAAA,MAAM,EAAE,QAAQ,CAAC,MAHU;AAI3B,YAAA,MAAM,EAAE,KAAK,KAAL,CAAW,KAAX,CAAiB,MAJE;AAK3B,YAAA,qBAAqB,EAAE,mBAAmB,CAAC;AALhB,WAFpB,CAAT;;AASA,cAAI,QAAJ,EAAc;AACZ,YAAA,SAAS,CAAC,GAAV,GAAgB,mBAAmB,CAAC,GAApC;AACA,YAAA,SAAS,CAAC,aAAV,GAA0B,mBAAmB,CAAC,QAA9C;AACD,WAHD,MAGO,IAAI,SAAS,CAAC,WAAV,KAA0B,KAA9B,EAAqC;AAC1C,gBAAM,CAAC,GAAG,KAAK,eAAL,CAAqB,gBAArB,CAAsC,SAAtC,CAAV;AACA,YAAA,SAAS,CAAC,aAAV,GAA0B,CAAC,KAAA,IAAD,IAAA,CAAC,KAAA,KAAA,CAAD,GAAC,KAAA,CAAD,GAAA,CAAC,CAAE,aAA7B;AACD,WAHM,MAGA,IAAI,SAAS,CAAC,WAAV,KAA0B,MAA1B,IAAoC,SAAS,CAAC,GAAV,KAAkB,mBAAmB,CAAC,GAA9E,EAAmF;;AAExF,gBAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,yBAArB,CAA+C,SAAS,CAAC,GAAzD,CAAlB;AACA,YAAA,SAAS,CAAC,aAAV,GAA0B,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,CAAE,aAArC;AACD,WAJM,MAIA,IAAI,SAAS,CAAC,WAAV,KAA0B,SAA9B,EAAyC;;AAE9C,gBAAM,gBAAgB,GAAG,KAAK,eAAL,CAAqB,OAArB,EAAzB;;;;;;;AAOA,gBAAM,eAAe,GAAG,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,aAA1C;AACA,gBAAM,aAAa,GAAI,eAAe,KAAK,SAApB,IAAiC,eAAe,KAAK,SAAS,CAAC,QAAhE,GAA4E,eAA5E,GAA8F,SAAS,CAAC,aAA9H;AAEA,YAAA,SAAS,CAAC,YAAV,GAAyB,CAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,QAAlB,KAA8B,SAAS,CAAC,YAAjE;AACA,YAAA,SAAS,CAAC,qBAAV,GAAkC,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,YAApD;AACA,YAAA,SAAS,CAAC,aAAV,GAA0B,aAA1B;AACA,YAAA,SAAS,CAAC,cAAV,GAA2B,CAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,cAAlB,KAAoC,SAAS,CAAC,cAAzE;AACA,YAAA,SAAS,CAAC,cAAV,GAA2B,CAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,cAAlB,KAAoC,SAAS,CAAC,cAAzE;AACD;;AAED,eAAK,eAAL,CAAqB,GAArB,CAAyB,SAAzB;AACD;;AAED,aAAK,QAAL,CAAc;AACZ,UAAA,SAAS,EAAT;AADY,SAAd;AAGD;;AAED,WAAK,mBAAL,GAA2B,SAA3B;AACD;;;;;;;;;;WAQD,4BAAgB;AACd,UAAM,OAAO,GAAG,KAAK,KAAL,CAAW,OAA3B;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,OAAO,CAAC,IAAzC;AACA,MAAA,MAAM;AACP;;;WAED,wBACE,IADF,EAEE,WAFF,EAGE,cAHF,EAIE,cAJF,EAKE,YALF,EAME,GANF,EAMc;AAEZ,WAAK,mBAAL,GAA2B,MAAM,CAAC,MAAP,CAAc,KAAK,mBAAL,IAA4B,EAA1C,EAA8C;AACvE,QAAA,WAAW,EAAX,WADuE;AAEvE,QAAA,cAAc,EAAd,cAFuE;AAGvE,QAAA,YAAY,EAAZ,YAHuE;AAIvE,QAAA,cAAc,EAAd,cAJuE;AAKvE,QAAA,GAAG,EAAH;AALuE,OAA9C,CAA3B;;AAQA,UAAI,WAAW,KAAK,MAApB,EAA4B;AAC1B,aAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,CAAwB,IAAxB;AACD,OAFD,MAEO;AACL,aAAK,KAAL,CAAW,OAAX,CAAmB,OAAnB,CAA2B,IAA3B;AACD;AACF;;;WAED,8BAA2F;AAAA,UAAxE,WAAwE,uEAAtC,GAAsC;AAAA,UAAjC,cAAiC;AACzF,UAAM,MAAM,GAAG,SAAS,EAAxB;AACA,MAAA,WAAW,GAAG,WAAW,GAAG,WAAH,GAAiB,MAAM,IAAI,MAAM,CAAC,GAAP,CAAW,uBAAX,CAApD;AACA,UAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,OAArB,EAAlB;;AACA,UAAI,SAAS,IAAI,SAAS,CAAC,aAA3B,EAA0C;AACxC,YAAM,QAAQ,GAAG,KAAK,eAAL,CAAqB,gBAArB,CAAsC,SAAtC,CAAjB;;AACA,YAAI,QAAJ,EAAc;AACZ,eAAK,mBAAL,GAAwB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACnB,QADmB,CAAA,EACX;AACX,YAAA,WAAW,EAAE,KADF;AAEX,YAAA,cAAc,EAAE,MAFL;AAGX,YAAA,cAAc,EAAE,cAAc,IAAI,SAAS,CAAC;AAHjC,WADW,CAAxB;;AAMA,cACE,SAAS,CAAC,YAAV,KAA2B,SAAS,CAAC,aAArC;;;;;;;AAQE,UAAA,QAAQ,CAAC,QAAT,KAAsB,SAAS,CAAC,aAAhC,IACA,SAAS,CAAC,GAAV,KAAkB,EADlB,IACwB,QAAQ,CAAC,GAAT,KAAiB,EAV7C,EAYE;;;;;;;AAOA,gBAAM,OAAO,GAAG,KAAK,KAAL,CAAW,OAA3B;AACA,gBAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,OAAO,CAAC,IAAzC;AACA,YAAA,MAAM;AACP,WAtBD,MAsBO;AACL,iBAAK,cAAL,CAAoB,QAAQ,CAAC,QAAT,IAAqB,QAAQ,CAAC,MAAT,IAAmB,EAAxC,CAApB,EAAiE,KAAjE,EAAwE,MAAxE;AACD;AACF,SAhCD,MAgCO;AACL,eAAK,cAAL,CAAoB,WAApB,EAA2C,KAA3C,EAAkD,MAAlD;AACD;AACF,OArCD,MAqCO;AACL,aAAK,cAAL,CAAoB,WAApB,EAA2C,KAA3C,EAAkD,MAAlD;AACD;AACF;;;WAED,wBAAe,GAAf,EAA4B,YAA5B,EAAkD,oBAAlD,EAA2E;AACzE,UAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,uBAArB,CAA6C,GAA7C,CAAlB;;AACA,UAAI,SAAJ,EAAe;AACb,YAAM,YAAY,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,SAAR,CAAlB;AACA,QAAA,YAAY,CAAC,QAAb,GAAwB,YAAxB;AACA,QAAA,YAAY,CAAC,YAAb,GAA4B,oBAA5B;AACA,aAAK,mBAAL,GAAwB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,YAAR,CAAA,EAAoB;AAAE,UAAA,WAAW,EAAE,KAAf;AAAsB,UAAA,cAAc,EAAE;AAAtC,SAApB,CAAxB;AACA,aAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,CAAwB,YAAY,CAAC,QAAb,IAAyB,YAAY,CAAC,MAAb,IAAuB,EAAhD,CAAxB;AACD;AACF;;;WAED,6BAAoB,GAApB,EAA+B;AAC7B,WAAK,UAAL,GAAkB,GAAlB;AACA,UAAM,EAAE,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,KAAK,eAAL,CAAqB,OAArB,EAAR,CAAR;;AACA,UAAI,EAAE,CAAC,GAAH,KAAW,GAAf,EAAoB;AAClB,QAAA,EAAE,CAAC,GAAH,GAAS,GAAT;AACA,aAAK,eAAL,CAAqB,MAArB,CAA4B,EAA5B;AACD;AACF;;;WAED,kBAAM;AACJ,aACE,KAAA,CAAA,aAAA,CAAC,mBAAmB,CAAC,QAArB,EAA6B;AAAC,QAAA,KAAK,EAAE,KAAK;AAAb,OAA7B,EACE,KAAA,CAAA,aAAA,CAAC,UAAD,EAAW;AACT,QAAA,QAAQ,EAAE,aADD;AAET,QAAA,WAAW,EAAE,EAFJ;AAGT,QAAA,YAAY,EAAE,YAHL;AAIT,QAAA,SAAS,EAAE,KAAK,KAAL,CAAW,SAJb;AAKT,QAAA,YAAY,EAAE,KAAK,gBALV;AAMT,QAAA,cAAc,EAAE,KAAK,kBANZ;AAOT,QAAA,UAAU,EAAE,KAAK,cAPR;AAQT,QAAA,eAAe,EAAE,KAAK,mBARb;AAST,QAAA,WAAW,EAAE,KAAK,eATT;AAUT,QAAA,UAAU,EAAE,KAAK,cAVR;AAWT,QAAA,eAAe,EAAE,KAAK;AAXb,OAAX,EAaG,KAAK,KAAL,CAAW,QAbd,CADF,CADF;AAmBD;;;;EAlS0B,KAAK,CAAC,a;;AAqS5B,IAAM,SAAS,GAAG,UAAU,CAAC,cAAD,CAA5B;AACP,SAAS,CAAC,WAAV,GAAwB,WAAxB;;IC3Ta,c;;;;;AAIX,0BAAY,KAAZ,EAAsC;AAAA;;AAAA;;AACpC,gCAAM,KAAN;;AACM,QAAE,OAAF,GAAuB,KAAvB,CAAE,OAAF;AAAA,QAAc,IAAd,GAAkB,MAAA,CAAK,KAAL,EAAlB,CAAA,SAAA,CAAkB,CAAlB;;AACN,WAAK,OAAL,GAAe,OAAO,IAAIC,oBAAa,CAAC,IAAD,CAAvC;;AACA,WAAK,OAAL,CAAa,MAAb,CAAoB,OAAK,mBAAL,CAAyB,IAAzB,gCAApB;;AACA,WAAK,uBAAL,GAA+B,OAAK,uBAAL,CAA6B,IAA7B,gCAA/B;AALoC;AAMrC;;;;;;;;;;;;;WAUD,6BAAoB,QAApB,EAA+C,MAA/C,EAAoE;AACnE,UAAM,aAAa,GAAI,QAAgB,CAAC,QAAjB,IAA6B,QAApD;AACA,UAAM,WAAW,GAAI,QAAgB,CAAC,MAAjB,IAA2B,MAAhD;;AACA,UAAI,KAAK,oBAAT,EAA+B;AAC7B,aAAK,oBAAL,CAA0B,aAA1B,EAAyC,WAAzC;AACD;AACF;;;WAEA,iCAAwB,EAAxB,EAAsF;AACpF,WAAK,oBAAL,GAA4B,EAA5B;AACD;;;WAED,kBAAM;AACE,UAAA,EAAA,GAAyB,KAAzB,KAAA;AAAA,UAAE,QAAF,GAAU,EAAV,CAAE,QAAF;AAAA,UAAe,KAAf,GAAoB,MAAA,CAAA,EAAA,EAApB,CAAA,UAAA,CAAoB,CAApB;;AACN,aACE,KAAA,CAAA,aAAA,CAAC,MAAD,EAAO,MAAA,CAAA,MAAA,CAAA;AAAC,QAAA,OAAO,EAAE,KAAK;AAAf,OAAA,EAA4B,KAA5B,CAAP,EACE,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AAAC,QAAA,uBAAuB,EAAE,KAAK;AAA/B,OAAV,EAAmE,QAAnE,CADF,CADF;AAKD;;;;EAvCiC,KAAK,CAAC,S;;ICL7B,oB;;;;;AAIX,gCAAY,KAAZ,EAA4C;AAAA;;AAAA;;AAC1C,gCAAM,KAAN;AACA,WAAK,OAAL,GAAe,KAAK,CAAC,OAArB;;AACA,WAAK,OAAL,CAAa,MAAb,CAAoB,OAAK,mBAAL,CAAyB,IAAzB,gCAApB;;AACA,WAAK,uBAAL,GAA+B,OAAK,uBAAL,CAA6B,IAA7B,gCAA/B;AAJ0C;AAK3C;;;;;;;;;;;;;WAUD,6BAAoB,QAApB,EAA+C,MAA/C,EAAoE;AAClE,UAAM,aAAa,GAAI,QAAgB,CAAC,QAAjB,IAA6B,QAApD;AACA,UAAM,WAAW,GAAI,QAAgB,CAAC,MAAjB,IAA2B,MAAhD;;AACA,UAAI,KAAK,oBAAT,EAA+B;AAC7B,aAAK,oBAAL,CAA0B,aAA1B,EAAyC,WAAzC;AACD;AACF;;;WAED,iCAAwB,EAAxB,EAAsF;AACpF,WAAK,oBAAL,GAA4B,EAA5B;AACD;;;WAED,kBAAM;AACE,UAAA,EAAA,GAAyB,KAAzB,KAAA;AAAA,UAAE,QAAF,GAAU,EAAV,CAAE,QAAF;AAAA,UAAe,KAAf,GAAoB,MAAA,CAAA,EAAA,EAApB,CAAA,UAAA,CAAoB,CAApB;;AACN,aACE,KAAA,CAAA,aAAA,CAACC,QAAD,EAAO,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,KAAL,CAAP,EACE,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AAAC,QAAA,uBAAuB,EAAE,KAAK;AAA/B,OAAV,EAAmE,QAAnE,CADF,CADF;AAKD;;;;EAtCuC,KAAK,CAAC,S;;ICKnC,kB;;;;;AAIX,8BAAY,KAAZ,EAA0C;AAAA;;AAAA;;AACxC,iCAAM,KAAN;;AACM,QAAE,OAAF,GAAuB,KAAvB,CAAE,OAAF;AAAA,QAAc,IAAd,GAAkB,MAAA,CAAK,KAAL,EAAlB,CAAA,SAAA,CAAkB,CAAlB;;AACN,YAAK,OAAL,GAAe,OAAO,IAAID,iBAAa,CAAC,IAAD,CAAvC;;AACA,YAAK,OAAL,CAAa,MAAb,CAAoB,QAAK,mBAAL,CAAyB,IAAzB,iCAApB;;AACA,YAAK,uBAAL,GAA+B,QAAK,uBAAL,CAA6B,IAA7B,iCAA/B;AALwC;AAMzC;;;;;;;;;;;;;WAUD,6BAAoB,QAApB,EAA+C,MAA/C,EAAoE;AAClE,UAAM,aAAa,GAAI,QAAgB,CAAC,QAAjB,IAA6B,QAApD;AACA,UAAM,WAAW,GAAI,QAAgB,CAAC,MAAjB,IAA2B,MAAhD;;AACA,UAAI,KAAK,oBAAT,EAA+B;AAC7B,aAAK,oBAAL,CAA0B,aAA1B,EAAyC,WAAzC;AACD;AACF;;;WAED,iCAAwB,EAAxB,EAAsF;AACpF,WAAK,oBAAL,GAA4B,EAA5B;AACD;;;WAED,kBAAM;AACE,UAAA,EAAA,GAAyB,KAAzB,KAAA;AAAA,UAAE,QAAF,GAAU,EAAV,CAAE,QAAF;AAAA,UAAe,KAAf,GAAoB,MAAA,CAAA,EAAA,EAApB,CAAA,UAAA,CAAoB,CAApB;;AACN,aACE,KAAA,CAAA,aAAA,CAAC,MAAD,EAAO,MAAA,CAAA,MAAA,CAAA;AAAC,QAAA,OAAO,EAAE,KAAK;AAAf,OAAA,EAA4B,KAA5B,CAAP,EACE,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AAAC,QAAA,uBAAuB,EAAE,KAAK;AAA/B,OAAV,EAAmE,QAAnE,CADF,CADF;AAKD;;;;EAvCqC,KAAK,CAAC,S","sourcesContent":["import { IonRouteProps } from '@ionic/react';\nimport React from 'react';\nimport { Route } from 'react-router';\n\nexport class IonRouteInner extends React.PureComponent<IonRouteProps> {\n  render() {\n    return (\n      <Route\n        path={this.props.path}\n        exact={this.props.exact}\n        render={this.props.render}\n        computedMatch={(this.props as any).computedMatch}\n      />\n    );\n  }\n}\n","import {\n  IonRoute,\n  RouteInfo,\n  ViewItem,\n  ViewLifeCycleManager,\n  ViewStacks,\n  generateId,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router';\n\nexport class ReactRouterViewStack extends ViewStacks {\n  constructor() {\n    super();\n    this.createViewItem = this.createViewItem.bind(this);\n    this.findViewItemByRouteInfo = this.findViewItemByRouteInfo.bind(this);\n    this.findLeavingViewItemByRouteInfo = this.findLeavingViewItemByRouteInfo.bind(this);\n    this.getChildrenToRender = this.getChildrenToRender.bind(this);\n    this.findViewItemByPathname = this.findViewItemByPathname.bind(this);\n  }\n\n  createViewItem(\n    outletId: string,\n    reactElement: React.ReactElement,\n    routeInfo: RouteInfo,\n    page?: HTMLElement\n  ) {\n    const viewItem: ViewItem = {\n      id: generateId('viewItem'),\n      outletId,\n      ionPageElement: page,\n      reactElement,\n      mount: true,\n      ionRoute: false,\n    };\n\n    const matchProps = {\n      exact: reactElement.props.exact,\n      path: reactElement.props.path || reactElement.props.from,\n      component: reactElement.props.component,\n    };\n\n    const match = matchPath(routeInfo.pathname, matchProps);\n\n    if (reactElement.type === IonRoute) {\n      viewItem.ionRoute = true;\n      viewItem.disableIonPageManagement = reactElement.props.disableIonPageManagement;\n    }\n\n    viewItem.routeData = {\n      match,\n      childProps: reactElement.props,\n    };\n\n    return viewItem;\n  }\n\n  getChildrenToRender(outletId: string, ionRouterOutlet: React.ReactElement, routeInfo: RouteInfo) {\n    const viewItems = this.getViewItemsForOutlet(outletId);\n\n    // Sync latest routes with viewItems\n    React.Children.forEach(ionRouterOutlet.props.children, (child: React.ReactElement) => {\n      const viewItem = viewItems.find((v) => {\n        return matchComponent(child, v.routeData.childProps.path || v.routeData.childProps.from);\n      });\n      if (viewItem) {\n        viewItem.reactElement = child;\n      }\n    });\n\n    const children = viewItems.map((viewItem) => {\n      let clonedChild;\n      if (viewItem.ionRoute && !viewItem.disableIonPageManagement) {\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n      } else {\n        const match = matchComponent(viewItem.reactElement, routeInfo.pathname);\n        clonedChild = (\n          <ViewLifeCycleManager\n            key={`view-${viewItem.id}`}\n            mount={viewItem.mount}\n            removeView={() => this.remove(viewItem)}\n          >\n            {React.cloneElement(viewItem.reactElement, {\n              computedMatch: viewItem.routeData.match,\n            })}\n          </ViewLifeCycleManager>\n        );\n\n        if (!match && viewItem.routeData.match) {\n          viewItem.routeData.match = undefined;\n          viewItem.mount = false;\n        }\n      }\n\n      return clonedChild;\n    });\n    return children;\n  }\n\n  findViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string) {\n    const { viewItem, match } = this.findViewItemByPath(routeInfo.pathname, outletId);\n    if (viewItem && match) {\n      viewItem.routeData.match = match;\n    }\n    return viewItem;\n  }\n\n  findLeavingViewItemByRouteInfo(routeInfo: RouteInfo, outletId?: string, mustBeIonRoute = true) {\n    const { viewItem } = this.findViewItemByPath(\n      routeInfo.lastPathname!,\n      outletId,\n      false,\n      mustBeIonRoute\n    );\n    return viewItem;\n  }\n\n  findViewItemByPathname(pathname: string, outletId?: string) {\n    const { viewItem } = this.findViewItemByPath(pathname, outletId);\n    return viewItem;\n  }\n\n  private findViewItemByPath(\n    pathname: string,\n    outletId?: string,\n    forceExact?: boolean,\n    mustBeIonRoute?: boolean\n  ) {\n    let viewItem: ViewItem | undefined;\n    let match: ReturnType<typeof matchPath> | undefined;\n    let viewStack: ViewItem[];\n\n    if (outletId) {\n      viewStack = this.getViewItemsForOutlet(outletId);\n      viewStack.some(matchView);\n      if (!viewItem) {\n        viewStack.some(matchDefaultRoute);\n      }\n    } else {\n      const viewItems = this.getAllViewItems();\n      viewItems.some(matchView);\n      if (!viewItem) {\n        viewItems.some(matchDefaultRoute);\n      }\n    }\n\n    return { viewItem, match };\n\n    function matchView(v: ViewItem) {\n      if (mustBeIonRoute && !v.ionRoute) {\n        return false;\n      }\n      const matchProps = {\n        exact: forceExact ? true : v.routeData.childProps.exact,\n        path: v.routeData.childProps.path || v.routeData.childProps.from,\n        component: v.routeData.childProps.component,\n      };\n      const myMatch = matchPath(pathname, matchProps);\n      if (myMatch) {\n        viewItem = v;\n        match = myMatch;\n        return true;\n      }\n      return false;\n    }\n\n    function matchDefaultRoute(v: ViewItem) {\n      // try to find a route that doesn't have a path or from prop, that will be our default route\n      if (!v.routeData.childProps.path && !v.routeData.childProps.from) {\n        match = {\n          path: pathname,\n          url: pathname,\n          isExact: true,\n          params: {},\n        };\n        viewItem = v;\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","export function clonePageElement(leavingViewHtml: string | HTMLElement) {\n  let html: string;\n  if (typeof leavingViewHtml === 'string') {\n    html = leavingViewHtml;\n  } else {\n    html = leavingViewHtml.outerHTML;\n  }\n  if (document) {\n    const newEl = document.createElement('div');\n    newEl.innerHTML = html;\n    newEl.style.zIndex = '';\n    // Remove an existing back button so the new element doesn't get two of them\n    const ionBackButton = newEl.getElementsByTagName('ion-back-button');\n    if (ionBackButton[0]) {\n      ionBackButton[0].remove();\n    }\n    return newEl.firstChild as HTMLElement;\n  }\n  return undefined;\n}\n","import {\n  RouteInfo,\n  RouteManagerContext,\n  StackContext,\n  StackContextState,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport React from 'react';\nimport { matchPath } from 'react-router-dom';\n\nimport { clonePageElement } from './clonePageElement';\n\ninterface StackManagerProps {\n  routeInfo: RouteInfo;\n}\n\ninterface StackManagerState {}\n\nexport class StackManager extends React.PureComponent<StackManagerProps, StackManagerState> {\n  id: string;\n  context!: React.ContextType<typeof RouteManagerContext>;\n  ionRouterOutlet?: React.ReactElement;\n  routerOutletElement: HTMLIonRouterOutletElement | undefined;\n\n  stackContextValue: StackContextState = {\n    registerIonPage: this.registerIonPage.bind(this),\n    isInOutlet: () => true,\n  };\n\n  constructor(props: StackManagerProps) {\n    super(props);\n    this.registerIonPage = this.registerIonPage.bind(this);\n    this.transitionPage = this.transitionPage.bind(this);\n    this.handlePageTransition = this.handlePageTransition.bind(this);\n    this.id = generateId('routerOutlet');\n  }\n\n  componentDidMount() {\n    if (this.routerOutletElement) {\n      this.setupRouterOutlet(this.routerOutletElement);\n      // console.log(`SM Mount - ${this.routerOutletElement.id} (${this.id})`);\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: StackManagerProps) {\n    if (this.props.routeInfo.pathname !== prevProps.routeInfo.pathname) {\n      this.handlePageTransition(this.props.routeInfo);\n    }\n  }\n\n  componentWillUnmount() {\n    // console.log(`SM UNMount - ${(this.routerOutletElement?.id as any).id} (${this.id})`);\n    this.context.clearOutlet(this.id);\n  }\n\n  async handlePageTransition(routeInfo: RouteInfo) {\n    // If routerOutlet isn't quite ready, give it another try in a moment\n    if (!this.routerOutletElement || !this.routerOutletElement.commit) {\n      setTimeout(() => this.handlePageTransition(routeInfo), 10);\n    } else {\n      let enteringViewItem = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n      let leavingViewItem = this.context.findLeavingViewItemByRouteInfo(routeInfo, this.id);\n\n      if (!leavingViewItem && routeInfo.prevRouteLastPathname) {\n        leavingViewItem = this.context.findViewItemByPathname(\n          routeInfo.prevRouteLastPathname,\n          this.id\n        );\n      }\n\n      // Check if leavingViewItem should be unmounted\n      if (leavingViewItem) {\n        if (routeInfo.routeAction === 'replace') {\n          leavingViewItem.mount = false;\n        } else if (!(routeInfo.routeAction === 'push' && routeInfo.routeDirection === 'forward')) {\n          if (routeInfo.routeDirection !== 'none' && enteringViewItem !== leavingViewItem) {\n            leavingViewItem.mount = false;\n          }\n        } else if (routeInfo.routeOptions?.unmount) {\n          leavingViewItem.mount = false;\n        }\n      }\n\n      const enteringRoute = matchRoute(\n        this.ionRouterOutlet?.props.children,\n        routeInfo\n      ) as React.ReactElement;\n      if (enteringViewItem) {\n        enteringViewItem.reactElement = enteringRoute;\n      }\n      if (!enteringViewItem) {\n        if (enteringRoute) {\n          enteringViewItem = this.context.createViewItem(this.id, enteringRoute, routeInfo);\n          this.context.addViewItem(enteringViewItem);\n        }\n      }\n      if (enteringViewItem && enteringViewItem.ionPageElement) {\n        this.transitionPage(routeInfo, enteringViewItem, leavingViewItem);\n      } else if (leavingViewItem && !enteringRoute && !enteringViewItem) {\n        // If we have a leavingView but no entering view/route, we are probably leaving to\n        // another outlet, so hide this leavingView. We do it in a timeout to give time for a\n        // transition to finish.\n        // setTimeout(() => {\n        if (leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n        // }, 250);\n      }\n\n      this.forceUpdate();\n    }\n  }\n\n  registerIonPage(page: HTMLElement, routeInfo: RouteInfo) {\n    const foundView = this.context.findViewItemByRouteInfo(routeInfo, this.id);\n    if (foundView) {\n      foundView.ionPageElement = page;\n      foundView.ionRoute = true;\n    }\n    this.handlePageTransition(routeInfo);\n  }\n\n  async setupRouterOutlet(routerOutlet: HTMLIonRouterOutletElement) {\n    const canStart = () => {\n      const config = getConfig();\n      const swipeEnabled = config && config.get('swipeBackEnabled', routerOutlet.mode === 'ios');\n      if (swipeEnabled) {\n        return this.context.canGoBack();\n      } else {\n        return false;\n      }\n    };\n\n    const onStart = () => {\n      this.context.goBack();\n    };\n    routerOutlet.swipeHandler = {\n      canStart,\n      onStart,\n      onEnd: (_shouldContinue) => true,\n    };\n  }\n\n  async transitionPage(\n    routeInfo: RouteInfo,\n    enteringViewItem: ViewItem,\n    leavingViewItem?: ViewItem\n  ) {\n    const routerOutlet = this.routerOutletElement!;\n\n    const direction =\n      routeInfo.routeDirection === 'none' || routeInfo.routeDirection === 'root'\n        ? undefined\n        : routeInfo.routeDirection;\n\n    if (enteringViewItem && enteringViewItem.ionPageElement && this.routerOutletElement) {\n      if (\n        leavingViewItem &&\n        leavingViewItem.ionPageElement &&\n        enteringViewItem === leavingViewItem\n      ) {\n        // If a page is transitioning to another version of itself\n        // we clone it so we can have an animation to show\n\n        const match = matchComponent(leavingViewItem.reactElement, routeInfo.pathname, true);\n        if (match) {\n          const newLeavingElement = clonePageElement(leavingViewItem.ionPageElement.outerHTML);\n          if (newLeavingElement) {\n            this.routerOutletElement.appendChild(newLeavingElement);\n            await runCommit(enteringViewItem.ionPageElement, newLeavingElement);\n            this.routerOutletElement.removeChild(newLeavingElement);\n          }\n        } else {\n          await runCommit(enteringViewItem.ionPageElement, undefined);\n        }\n      } else {\n        await runCommit(enteringViewItem.ionPageElement, leavingViewItem?.ionPageElement);\n        if (leavingViewItem && leavingViewItem.ionPageElement) {\n          leavingViewItem.ionPageElement.classList.add('ion-page-hidden');\n          leavingViewItem.ionPageElement.setAttribute('aria-hidden', 'true');\n        }\n      }\n    }\n\n    async function runCommit(enteringEl: HTMLElement, leavingEl?: HTMLElement) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n\n      await routerOutlet.commit(enteringEl, leavingEl, {\n        deepWait: true,\n        duration: direction === undefined ? 0 : undefined,\n        direction: direction as any,\n        showGoBack: !!routeInfo.pushedByRoute,\n        progressAnimation: false,\n        animationBuilder: routeInfo.routeAnimation,\n      });\n    }\n  }\n\n  render() {\n    const { children } = this.props;\n    const ionRouterOutlet = React.Children.only(children) as React.ReactElement;\n    this.ionRouterOutlet = ionRouterOutlet;\n\n    const components = this.context.getChildrenToRender(\n      this.id,\n      this.ionRouterOutlet,\n      this.props.routeInfo,\n      () => {\n        this.forceUpdate();\n      }\n    );\n\n    return (\n      <StackContext.Provider value={this.stackContextValue}>\n        {React.cloneElement(\n          ionRouterOutlet as any,\n          {\n            ref: (node: HTMLIonRouterOutletElement) => {\n              if (ionRouterOutlet.props.setRef) {\n                ionRouterOutlet.props.setRef(node);\n              }\n              if (ionRouterOutlet.props.forwardedRef) {\n                ionRouterOutlet.props.forwardedRef.current = node;\n              }\n              this.routerOutletElement = node;\n              const { ref } = ionRouterOutlet as any;\n              if (typeof ref === 'function') {\n                ref(node);\n              }\n            },\n          },\n          components\n        )}\n      </StackContext.Provider>\n    );\n  }\n\n  static get contextType() {\n    return RouteManagerContext;\n  }\n}\n\nexport default StackManager;\n\nfunction matchRoute(node: React.ReactNode, routeInfo: RouteInfo) {\n  let matchedNode: React.ReactNode;\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    const matchProps = {\n      exact: child.props.exact,\n      path: child.props.path || child.props.from,\n      component: child.props.component,\n    };\n    const match = matchPath(routeInfo.pathname, matchProps);\n    if (match) {\n      matchedNode = child;\n    }\n  });\n\n  if (matchedNode) {\n    return matchedNode;\n  }\n  // If we haven't found a node\n  // try to find one that doesn't have a path or from prop, that will be our not found route\n  React.Children.forEach(node as React.ReactElement, (child: React.ReactElement) => {\n    if (!(child.props.path || child.props.from)) {\n      matchedNode = child;\n    }\n  });\n\n  return matchedNode;\n}\n\nfunction matchComponent(node: React.ReactElement, pathname: string, forceExact?: boolean) {\n  const matchProps = {\n    exact: forceExact ? true : node.props.exact,\n    path: node.props.path || node.props.from,\n    component: node.props.component,\n  };\n  const match = matchPath(pathname, matchProps);\n\n  return match;\n}\n","import {\n  AnimationBuilder,\n  LocationHistory,\n  NavManager,\n  RouteAction,\n  RouteInfo,\n  RouteManagerContext,\n  RouteManagerContextState,\n  RouterDirection,\n  ViewItem,\n  generateId,\n  getConfig,\n} from '@ionic/react';\nimport { Action as HistoryAction, Location as HistoryLocation } from 'history';\nimport React from 'react';\nimport { RouteComponentProps, withRouter } from 'react-router-dom';\n\nimport { IonRouteInner } from './IonRouteInner';\nimport { ReactRouterViewStack } from './ReactRouterViewStack';\nimport StackManager from './StackManager';\n\nexport interface LocationState {\n  direction?: RouterDirection;\n  routerOptions?: { as?: string; unmount?: boolean };\n}\n\ninterface IonRouteProps extends RouteComponentProps<{}, {}, LocationState> {\n  registerHistoryListener: (\n    cb: (location: HistoryLocation<any>, action: HistoryAction) => void\n  ) => void;\n}\n\ninterface IonRouteState {\n  routeInfo: RouteInfo;\n}\n\nclass IonRouterInner extends React.PureComponent<IonRouteProps, IonRouteState> {\n  currentTab?: string;\n  exitViewFromOtherOutletHandlers: ((pathname: string) => ViewItem | undefined)[] = [];\n  incomingRouteParams?: Partial<RouteInfo>;\n  locationHistory = new LocationHistory();\n  viewStack = new ReactRouterViewStack();\n  routeMangerContextState: RouteManagerContextState = {\n    canGoBack: () => this.locationHistory.canGoBack(),\n    clearOutlet: this.viewStack.clear,\n    findViewItemByPathname: this.viewStack.findViewItemByPathname,\n    getChildrenToRender: this.viewStack.getChildrenToRender,\n    goBack: () => this.handleNavigateBack(),\n    createViewItem: this.viewStack.createViewItem,\n    findViewItemByRouteInfo: this.viewStack.findViewItemByRouteInfo,\n    findLeavingViewItemByRouteInfo: this.viewStack.findLeavingViewItemByRouteInfo,\n    addViewItem: this.viewStack.add,\n    unMountViewItem: this.viewStack.remove,\n  };\n\n  constructor(props: IonRouteProps) {\n    super(props);\n\n    const routeInfo = {\n      id: generateId('routeInfo'),\n      pathname: this.props.location.pathname,\n      search: this.props.location.search,\n    };\n\n    this.locationHistory.add(routeInfo);\n    this.handleChangeTab = this.handleChangeTab.bind(this);\n    this.handleResetTab = this.handleResetTab.bind(this);\n    this.handleNativeBack = this.handleNativeBack.bind(this);\n    this.handleNavigate = this.handleNavigate.bind(this);\n    this.handleNavigateBack = this.handleNavigateBack.bind(this);\n    this.props.registerHistoryListener(this.handleHistoryChange.bind(this));\n    this.handleSetCurrentTab = this.handleSetCurrentTab.bind(this);\n\n    this.state = {\n      routeInfo,\n    };\n  }\n\n  handleChangeTab(tab: string, path?: string, routeOptions?: any) {\n    if (!path) { return; }\n\n    const routeInfo = this.locationHistory.getCurrentRouteInfoForTab(tab);\n    const [pathname, search] = path.split('?');\n    if (routeInfo) {\n      this.incomingRouteParams = { ...routeInfo, routeAction: 'push', routeDirection: 'none' };\n      if (routeInfo.pathname === pathname) {\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(routeInfo.pathname + (routeInfo.search || ''));\n      } else {\n        this.incomingRouteParams.pathname = pathname;\n        this.incomingRouteParams.search = search ? '?' + search : undefined;\n        this.incomingRouteParams.routeOptions = routeOptions;\n        this.props.history.push(pathname + (search ? '?' + search : ''));\n      }\n    } else {\n      this.handleNavigate(pathname, 'push', 'none', undefined, routeOptions, tab);\n    }\n  }\n\n  handleHistoryChange(location: HistoryLocation<LocationState>, action: HistoryAction) {\n    let leavingLocationInfo: RouteInfo;\n    if (this.incomingRouteParams) {\n      if (this.incomingRouteParams.routeAction === 'replace') {\n        leavingLocationInfo = this.locationHistory.previous();\n      } else {\n        leavingLocationInfo = this.locationHistory.current();\n      }\n    } else {\n      leavingLocationInfo = this.locationHistory.current();\n    }\n\n    const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n    if (leavingUrl !== location.pathname) {\n      if (!this.incomingRouteParams) {\n        if (action === 'REPLACE') {\n          this.incomingRouteParams = {\n            routeAction: 'replace',\n            routeDirection: 'none',\n            tab: this.currentTab, // TODO this isn't legit if replacing to a page that is not in the tabs\n          };\n        }\n        if (action === 'POP') {\n          const currentRoute = this.locationHistory.current();\n          if (currentRoute && currentRoute.pushedByRoute) {\n            const prevInfo = this.locationHistory.findLastLocation(currentRoute);\n            this.incomingRouteParams = { ...prevInfo, routeAction: 'pop', routeDirection: 'back' };\n          } else {\n            this.incomingRouteParams = {\n              routeAction: 'pop',\n              routeDirection: 'none',\n              tab: this.currentTab,\n            };\n          }\n        }\n        if (!this.incomingRouteParams) {\n          this.incomingRouteParams = {\n            routeAction: 'push',\n            routeDirection: location.state?.direction || 'forward',\n            routeOptions: location.state?.routerOptions,\n            tab: this.currentTab,\n          };\n        }\n      }\n\n      let routeInfo: RouteInfo;\n\n      if (this.incomingRouteParams?.id) {\n        routeInfo = {\n          ...(this.incomingRouteParams as RouteInfo),\n          lastPathname: leavingLocationInfo.pathname,\n        };\n        this.locationHistory.add(routeInfo);\n      } else {\n        const isPushed =\n          this.incomingRouteParams.routeAction === 'push' &&\n          this.incomingRouteParams.routeDirection === 'forward';\n        routeInfo = {\n          id: generateId('routeInfo'),\n          ...this.incomingRouteParams,\n          lastPathname: leavingLocationInfo.pathname,\n          pathname: location.pathname,\n          search: location.search,\n          params: this.props.match.params,\n          prevRouteLastPathname: leavingLocationInfo.lastPathname,\n        };\n        if (isPushed) {\n          routeInfo.tab = leavingLocationInfo.tab;\n          routeInfo.pushedByRoute = leavingLocationInfo.pathname;\n        } else if (routeInfo.routeAction === 'pop') {\n          const r = this.locationHistory.findLastLocation(routeInfo);\n          routeInfo.pushedByRoute = r?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'push' && routeInfo.tab !== leavingLocationInfo.tab) {\n          // If we are switching tabs grab the last route info for the tab and use its pushedByRoute\n          const lastRoute = this.locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n          routeInfo.pushedByRoute = lastRoute?.pushedByRoute;\n        } else if (routeInfo.routeAction === 'replace') {\n          // Make sure to set the lastPathname, etc.. to the current route so the page transitions out\n          const currentRouteInfo = this.locationHistory.current();\n\n          /**\n           * If going from /home to /child, then replacing from\n           * /child to /home, we don't want the route info to\n           * say that /home was pushed by /home which is not correct.\n           */\n          const currentPushedBy = currentRouteInfo?.pushedByRoute;\n          const pushedByRoute = (currentPushedBy !== undefined && currentPushedBy !== routeInfo.pathname) ? currentPushedBy : routeInfo.pushedByRoute;\n\n          routeInfo.lastPathname = currentRouteInfo?.pathname || routeInfo.lastPathname;\n          routeInfo.prevRouteLastPathname = currentRouteInfo?.lastPathname;\n          routeInfo.pushedByRoute = pushedByRoute;\n          routeInfo.routeDirection = currentRouteInfo?.routeDirection || routeInfo.routeDirection;\n          routeInfo.routeAnimation = currentRouteInfo?.routeAnimation || routeInfo.routeAnimation;\n        }\n\n        this.locationHistory.add(routeInfo);\n      }\n\n      this.setState({\n        routeInfo,\n      });\n    }\n\n    this.incomingRouteParams = undefined;\n  }\n\n  /**\n   * history@4.x uses goBack(), history@5.x uses back()\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just\n   * assume back() is available.\n   */\n  handleNativeBack() {\n    const history = this.props.history as any;\n    const goBack = history.goBack || history.back;\n    goBack();\n  }\n\n  handleNavigate(\n    path: string,\n    routeAction: RouteAction,\n    routeDirection?: RouterDirection,\n    routeAnimation?: AnimationBuilder,\n    routeOptions?: any,\n    tab?: string\n  ) {\n    this.incomingRouteParams = Object.assign(this.incomingRouteParams || {}, {\n      routeAction,\n      routeDirection,\n      routeOptions,\n      routeAnimation,\n      tab,\n    });\n\n    if (routeAction === 'push') {\n      this.props.history.push(path);\n    } else {\n      this.props.history.replace(path);\n    }\n  }\n\n  handleNavigateBack(defaultHref: string | RouteInfo = '/', routeAnimation?: AnimationBuilder) {\n    const config = getConfig();\n    defaultHref = defaultHref ? defaultHref : config && config.get('backButtonDefaultHref' as any);\n    const routeInfo = this.locationHistory.current();\n    if (routeInfo && routeInfo.pushedByRoute) {\n      const prevInfo = this.locationHistory.findLastLocation(routeInfo);\n      if (prevInfo) {\n        this.incomingRouteParams = {\n          ...prevInfo,\n          routeAction: 'pop',\n          routeDirection: 'back',\n          routeAnimation: routeAnimation || routeInfo.routeAnimation,\n        };\n        if (\n          routeInfo.lastPathname === routeInfo.pushedByRoute ||\n          (\n            /**\n             * We need to exclude tab switches/tab\n             * context changes here because tabbed\n             * navigation is not linear, but router.back()\n             * will go back in a linear fashion.\n             */\n            prevInfo.pathname === routeInfo.pushedByRoute &&\n            routeInfo.tab === '' && prevInfo.tab === ''\n          )\n        ) {\n          /**\n           * history@4.x uses goBack(), history@5.x uses back()\n           * TODO: If support for React Router <=5 is dropped\n           * this logic is no longer needed. We can just\n           * assume back() is available.\n           */\n          const history = this.props.history as any;\n          const goBack = history.goBack || history.back;\n          goBack();\n        } else {\n          this.handleNavigate(prevInfo.pathname + (prevInfo.search || ''), 'pop', 'back');\n        }\n      } else {\n        this.handleNavigate(defaultHref as string, 'pop', 'back');\n      }\n    } else {\n      this.handleNavigate(defaultHref as string, 'pop', 'back');\n    }\n  }\n\n  handleResetTab(tab: string, originalHref: string, originalRouteOptions: any) {\n    const routeInfo = this.locationHistory.getFirstRouteInfoForTab(tab);\n    if (routeInfo) {\n      const newRouteInfo = { ...routeInfo };\n      newRouteInfo.pathname = originalHref;\n      newRouteInfo.routeOptions = originalRouteOptions;\n      this.incomingRouteParams = { ...newRouteInfo, routeAction: 'pop', routeDirection: 'back' };\n      this.props.history.push(newRouteInfo.pathname + (newRouteInfo.search || ''));\n    }\n  }\n\n  handleSetCurrentTab(tab: string) {\n    this.currentTab = tab;\n    const ri = { ...this.locationHistory.current() };\n    if (ri.tab !== tab) {\n      ri.tab = tab;\n      this.locationHistory.update(ri);\n    }\n  }\n\n  render() {\n    return (\n      <RouteManagerContext.Provider value={this.routeMangerContextState}>\n        <NavManager\n          ionRoute={IonRouteInner}\n          ionRedirect={{}}\n          stackManager={StackManager}\n          routeInfo={this.state.routeInfo!}\n          onNativeBack={this.handleNativeBack}\n          onNavigateBack={this.handleNavigateBack}\n          onNavigate={this.handleNavigate}\n          onSetCurrentTab={this.handleSetCurrentTab}\n          onChangeTab={this.handleChangeTab}\n          onResetTab={this.handleResetTab}\n          locationHistory={this.locationHistory}\n        >\n          {this.props.children}\n        </NavManager>\n      </RouteManagerContext.Provider>\n    );\n  }\n}\n\nexport const IonRouter = withRouter(IonRouterInner);\nIonRouter.displayName = 'IonRouter';\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createBrowserHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactRouter extends React.Component<IonReactRouterProps> {\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n  history: History;\n\n  constructor(props: IonReactRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n /**\n  * history@4.x passes separate location and action\n  * params. history@5.x passes location and action\n  * together as a single object.\n  * TODO: If support for React Router <=5 is dropped\n  * this logic is no longer needed. We can just assume\n  * a single object with both location and action.\n  */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n   const locationValue = (location as any).location || location;\n   const actionValue = (location as any).action || action;\n   if (this.historyListenHandler) {\n     this.historyListenHandler(locationValue, actionValue);\n   }\n }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import { Action as HistoryAction, Location as HistoryLocation, MemoryHistory } from 'history';\nimport React from 'react';\nimport { MemoryRouterProps, Router } from 'react-router';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactMemoryRouterProps extends MemoryRouterProps {\n  history: MemoryHistory;\n}\n\nexport class IonReactMemoryRouter extends React.Component<IonReactMemoryRouterProps> {\n  history: MemoryHistory;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactMemoryRouterProps) {\n    super(props);\n    this.history = props.history;\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n","import {\n  Action as HistoryAction,\n  History,\n  Location as HistoryLocation,\n  createHashHistory as createHistory,\n} from 'history';\nimport React from 'react';\nimport { BrowserRouterProps, Router } from 'react-router-dom';\n\nimport { IonRouter } from './IonRouter';\n\ninterface IonReactHashRouterProps extends BrowserRouterProps {\n  history?: History;\n}\n\nexport class IonReactHashRouter extends React.Component<IonReactHashRouterProps> {\n  history: History;\n  historyListenHandler?: (location: HistoryLocation, action: HistoryAction) => void;\n\n  constructor(props: IonReactHashRouterProps) {\n    super(props);\n    const { history, ...rest } = props;\n    this.history = history || createHistory(rest);\n    this.history.listen(this.handleHistoryChange.bind(this));\n    this.registerHistoryListener = this.registerHistoryListener.bind(this);\n  }\n\n  /**\n   * history@4.x passes separate location and action\n   * params. history@5.x passes location and action\n   * together as a single object.\n   * TODO: If support for React Router <=5 is dropped\n   * this logic is no longer needed. We can just assume\n   * a single object with both location and action.\n   */\n  handleHistoryChange(location: HistoryLocation, action: HistoryAction) {\n    const locationValue = (location as any).location || location;\n    const actionValue = (location as any).action || action;\n    if (this.historyListenHandler) {\n      this.historyListenHandler(locationValue, actionValue);\n    }\n  }\n\n  registerHistoryListener(cb: (location: HistoryLocation, action: HistoryAction) => void) {\n    this.historyListenHandler = cb;\n  }\n\n  render() {\n    const { children, ...props } = this.props;\n    return (\n      <Router history={this.history} {...props}>\n        <IonRouter registerHistoryListener={this.registerHistoryListener}>{children}</IonRouter>\n      </Router>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}