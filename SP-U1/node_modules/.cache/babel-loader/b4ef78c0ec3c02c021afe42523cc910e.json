{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\n\nvar wrappedFetch = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var request, fetchOptions, event, _ref$plugins, plugins, possiblePreloadResponse, failedFetchPlugins, originalRequest, _iterator, _step, plugin, pluginMethod, requestClone, pluginFilteredRequest, fetchResponse, _iterator2, _step2, _plugin, _iterator3, _step3, _plugin2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            request = _ref.request, fetchOptions = _ref.fetchOptions, event = _ref.event, _ref$plugins = _ref.plugins, plugins = _ref$plugins === void 0 ? [] : _ref$plugins;\n\n            if (typeof request === 'string') {\n              request = new Request(request);\n            } // We *should* be able to call `await event.preloadResponse` even if it's\n            // undefined, but for some reason, doing so leads to errors in our Node unit\n            // tests. To work around that, explicitly check preloadResponse's value first.\n\n\n            if (!(event instanceof FetchEvent && event.preloadResponse)) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 5;\n            return event.preloadResponse;\n\n          case 5:\n            possiblePreloadResponse = _context.sent;\n\n            if (!possiblePreloadResponse) {\n              _context.next = 9;\n              break;\n            }\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n            }\n\n            return _context.abrupt(\"return\", possiblePreloadResponse);\n\n          case 9:\n            if (process.env.NODE_ENV !== 'production') {\n              assert.isInstance(request, Request, {\n                paramName: 'request',\n                expectedClass: Request,\n                moduleName: 'workbox-core',\n                className: 'fetchWrapper',\n                funcName: 'wrappedFetch'\n              });\n            }\n\n            failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\"\n            /* FETCH_DID_FAIL */\n            ); // If there is a fetchDidFail plugin, we need to save a clone of the\n            // original request before it's either modified by a requestWillFetch\n            // plugin or before the original request's body is consumed via fetch().\n\n            originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n            _context.prev = 12;\n            _iterator = _createForOfIteratorHelper(plugins);\n            _context.prev = 14;\n\n            _iterator.s();\n\n          case 16:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 27;\n              break;\n            }\n\n            plugin = _step.value;\n\n            if (!(\"requestWillFetch\"\n            /* REQUEST_WILL_FETCH */\n            in plugin)) {\n              _context.next = 25;\n              break;\n            }\n\n            pluginMethod = plugin[\"requestWillFetch\"\n            /* REQUEST_WILL_FETCH */\n            ];\n            requestClone = request.clone();\n            _context.next = 23;\n            return pluginMethod.call(plugin, {\n              request: requestClone,\n              event: event\n            });\n\n          case 23:\n            request = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (request) {\n                assert.isInstance(request, Request, {\n                  moduleName: 'Plugin',\n                  funcName: \"cachedResponseWillBeUsed\"\n                  /* CACHED_RESPONSE_WILL_BE_USED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 25:\n            _context.next = 16;\n            break;\n\n          case 27:\n            _context.next = 32;\n            break;\n\n          case 29:\n            _context.prev = 29;\n            _context.t0 = _context[\"catch\"](14);\n\n            _iterator.e(_context.t0);\n\n          case 32:\n            _context.prev = 32;\n\n            _iterator.f();\n\n            return _context.finish(32);\n\n          case 35:\n            _context.next = 40;\n            break;\n\n          case 37:\n            _context.prev = 37;\n            _context.t1 = _context[\"catch\"](12);\n            throw new WorkboxError('plugin-error-request-will-fetch', {\n              thrownError: _context.t1\n            });\n\n          case 40:\n            // The request can be altered by plugins with `requestWillFetch` making\n            // the original request (Most likely from a `fetch` event) to be different\n            // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n            pluginFilteredRequest = request.clone();\n            _context.prev = 41;\n\n            if (!(request.mode === 'navigate')) {\n              _context.next = 48;\n              break;\n            }\n\n            _context.next = 45;\n            return fetch(request);\n\n          case 45:\n            fetchResponse = _context.sent;\n            _context.next = 51;\n            break;\n\n          case 48:\n            _context.next = 50;\n            return fetch(request, fetchOptions);\n\n          case 50:\n            fetchResponse = _context.sent;\n\n          case 51:\n            if (process.env.NODE_ENV !== 'production') {\n              logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n            }\n\n            _iterator2 = _createForOfIteratorHelper(plugins);\n            _context.prev = 53;\n\n            _iterator2.s();\n\n          case 55:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 64;\n              break;\n            }\n\n            _plugin = _step2.value;\n\n            if (!(\"fetchDidSucceed\"\n            /* FETCH_DID_SUCCEED */\n            in _plugin)) {\n              _context.next = 62;\n              break;\n            }\n\n            _context.next = 60;\n            return _plugin[\"fetchDidSucceed\"\n            /* FETCH_DID_SUCCEED */\n            ].call(_plugin, {\n              event: event,\n              request: pluginFilteredRequest,\n              response: fetchResponse\n            });\n\n          case 60:\n            fetchResponse = _context.sent;\n\n            if (process.env.NODE_ENV !== 'production') {\n              if (fetchResponse) {\n                assert.isInstance(fetchResponse, Response, {\n                  moduleName: 'Plugin',\n                  funcName: \"fetchDidSucceed\"\n                  /* FETCH_DID_SUCCEED */\n                  ,\n                  isReturnValueProblem: true\n                });\n              }\n            }\n\n          case 62:\n            _context.next = 55;\n            break;\n\n          case 64:\n            _context.next = 69;\n            break;\n\n          case 66:\n            _context.prev = 66;\n            _context.t2 = _context[\"catch\"](53);\n\n            _iterator2.e(_context.t2);\n\n          case 69:\n            _context.prev = 69;\n\n            _iterator2.f();\n\n            return _context.finish(69);\n\n          case 72:\n            return _context.abrupt(\"return\", fetchResponse);\n\n          case 75:\n            _context.prev = 75;\n            _context.t3 = _context[\"catch\"](41);\n\n            if (process.env.NODE_ENV !== 'production') {\n              logger.error(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t3);\n            }\n\n            _iterator3 = _createForOfIteratorHelper(failedFetchPlugins);\n            _context.prev = 79;\n\n            _iterator3.s();\n\n          case 81:\n            if ((_step3 = _iterator3.n()).done) {\n              _context.next = 87;\n              break;\n            }\n\n            _plugin2 = _step3.value;\n            _context.next = 85;\n            return _plugin2[\"fetchDidFail\"\n            /* FETCH_DID_FAIL */\n            ].call(_plugin2, {\n              error: _context.t3,\n              event: event,\n              originalRequest: originalRequest.clone(),\n              request: pluginFilteredRequest.clone()\n            });\n\n          case 85:\n            _context.next = 81;\n            break;\n\n          case 87:\n            _context.next = 92;\n            break;\n\n          case 89:\n            _context.prev = 89;\n            _context.t4 = _context[\"catch\"](79);\n\n            _iterator3.e(_context.t4);\n\n          case 92:\n            _context.prev = 92;\n\n            _iterator3.f();\n\n            return _context.finish(92);\n\n          case 95:\n            throw _context.t3;\n\n          case 96:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[12, 37], [14, 29, 32, 35], [41, 75], [53, 66, 69, 72], [79, 89, 92, 95]]);\n  }));\n\n  return function wrappedFetch(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar fetchWrapper = {\n  fetch: wrappedFetch\n};\nexport { fetchWrapper };","map":{"version":3,"sources":["/Users/tm/Documents/CODE/STUDYPELAGO/node_modules/workbox-core/_private/fetchWrapper.js"],"names":["WorkboxError","logger","assert","getFriendlyURL","pluginUtils","wrappedFetch","request","fetchOptions","event","plugins","Request","FetchEvent","preloadResponse","possiblePreloadResponse","process","env","NODE_ENV","log","url","isInstance","paramName","expectedClass","moduleName","className","funcName","failedFetchPlugins","filter","originalRequest","length","clone","plugin","pluginMethod","requestClone","call","isReturnValueProblem","thrownError","pluginFilteredRequest","mode","fetch","fetchResponse","debug","status","response","Response","error","fetchWrapper"],"mappings":"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","sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { WorkboxError } from './WorkboxError.js';\nimport { logger } from './logger.js';\nimport { assert } from './assert.js';\nimport { getFriendlyURL } from '../_private/getFriendlyURL.js';\nimport { pluginUtils } from '../utils/pluginUtils.js';\nimport '../_version.js';\n/**\n * Wrapper around the fetch API.\n *\n * Will call requestWillFetch on available plugins.\n *\n * @param {Object} options\n * @param {Request|string} options.request\n * @param {Object} [options.fetchOptions]\n * @param {ExtendableEvent} [options.event]\n * @param {Array<Object>} [options.plugins=[]]\n * @return {Promise<Response>}\n *\n * @private\n * @memberof module:workbox-core\n */\nconst wrappedFetch = async ({ request, fetchOptions, event, plugins = [], }) => {\n    if (typeof request === 'string') {\n        request = new Request(request);\n    }\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event instanceof FetchEvent && event.preloadResponse) {\n        const possiblePreloadResponse = await event.preloadResponse;\n        if (possiblePreloadResponse) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Using a preloaded navigation response for ` +\n                    `'${getFriendlyURL(request.url)}'`);\n            }\n            return possiblePreloadResponse;\n        }\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isInstance(request, Request, {\n            paramName: 'request',\n            expectedClass: Request,\n            moduleName: 'workbox-core',\n            className: 'fetchWrapper',\n            funcName: 'wrappedFetch',\n        });\n    }\n    const failedFetchPlugins = pluginUtils.filter(plugins, \"fetchDidFail\" /* FETCH_DID_FAIL */);\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = failedFetchPlugins.length > 0 ?\n        request.clone() : null;\n    try {\n        for (const plugin of plugins) {\n            if (\"requestWillFetch\" /* REQUEST_WILL_FETCH */ in plugin) {\n                const pluginMethod = plugin[\"requestWillFetch\" /* REQUEST_WILL_FETCH */];\n                const requestClone = request.clone();\n                request = await pluginMethod.call(plugin, {\n                    request: requestClone,\n                    event,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (request) {\n                        assert.isInstance(request, Request, {\n                            moduleName: 'Plugin',\n                            funcName: \"cachedResponseWillBeUsed\" /* CACHED_RESPONSE_WILL_BE_USED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    catch (err) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n            thrownError: err,\n        });\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n        let fetchResponse;\n        // See https://github.com/GoogleChrome/workbox/issues/1796\n        if (request.mode === 'navigate') {\n            fetchResponse = await fetch(request);\n        }\n        else {\n            fetchResponse = await fetch(request, fetchOptions);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' returned a response with ` +\n                `status '${fetchResponse.status}'.`);\n        }\n        for (const plugin of plugins) {\n            if (\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */ in plugin) {\n                fetchResponse = await plugin[\"fetchDidSucceed\" /* FETCH_DID_SUCCEED */]\n                    .call(plugin, {\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n                if (process.env.NODE_ENV !== 'production') {\n                    if (fetchResponse) {\n                        assert.isInstance(fetchResponse, Response, {\n                            moduleName: 'Plugin',\n                            funcName: \"fetchDidSucceed\" /* FETCH_DID_SUCCEED */,\n                            isReturnValueProblem: true,\n                        });\n                    }\n                }\n            }\n        }\n        return fetchResponse;\n    }\n    catch (error) {\n        if (process.env.NODE_ENV !== 'production') {\n            logger.error(`Network request for ` +\n                `'${getFriendlyURL(request.url)}' threw an error.`, error);\n        }\n        for (const plugin of failedFetchPlugins) {\n            await plugin[\"fetchDidFail\" /* FETCH_DID_FAIL */].call(plugin, {\n                error,\n                event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone(),\n            });\n        }\n        throw error;\n    }\n};\nconst fetchWrapper = {\n    fetch: wrappedFetch,\n};\nexport { fetchWrapper };\n"]},"metadata":{},"sourceType":"module"}