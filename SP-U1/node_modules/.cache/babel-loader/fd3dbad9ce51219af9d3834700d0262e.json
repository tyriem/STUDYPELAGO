{"ast":null,"code":"import _toConsumableArray from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\n\nvar PrecacheController = /*#__PURE__*/function () {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} [cacheName] An optional name for the cache, to override\n   * the default precache name.\n   */\n  function PrecacheController(cacheName) {\n    _classCallCheck(this, PrecacheController);\n\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to precache.\n   */\n\n\n  _createClass(PrecacheController, [{\n    key: \"addToCacheList\",\n    value: function addToCacheList(entries) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n\n      var urlsToWarnAbout = [];\n\n      var _iterator = _createForOfIteratorHelper(entries),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n\n          var _createCacheKey = createCacheKey(entry),\n              cacheKey = _createCacheKey.cacheKey,\n              url = _createCacheKey.url;\n\n          var cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url: url\n              });\n            }\n\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n\n          this._urlsToCacheKeys.set(url, cacheKey);\n\n          this._urlsToCacheModes.set(url, cacheMode);\n\n          if (urlsToWarnAbout.length > 0) {\n            var warningMessage = \"Workbox is precaching URLs without revision \" + \"info: \".concat(urlsToWarnAbout.join(', '), \"\\nThis is generally NOT safe. \") + \"Learn more at https://bit.ly/wb-precache\";\n\n            if (process.env.NODE_ENV === 'production') {\n              // Use console directly to display this warning without bloating\n              // bundle sizes by pulling in all of the logger codebase in prod.\n              console.warn(warningMessage);\n            } else {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n\n  }, {\n    key: \"install\",\n    value: function () {\n      var _install = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var _ref,\n            event,\n            plugins,\n            toBePrecached,\n            alreadyPrecached,\n            cache,\n            alreadyCachedRequests,\n            existingCacheKeys,\n            _iterator2,\n            _step2,\n            _step2$value,\n            url,\n            cacheKey,\n            precacheRequests,\n            updatedURLs,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, event = _ref.event, plugins = _ref.plugins;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (plugins) {\n                    assert.isArray(plugins, {\n                      moduleName: 'workbox-precaching',\n                      className: 'PrecacheController',\n                      funcName: 'install',\n                      paramName: 'plugins'\n                    });\n                  }\n                }\n\n                toBePrecached = [];\n                alreadyPrecached = [];\n                _context.next = 6;\n                return self.caches.open(this._cacheName);\n\n              case 6:\n                cache = _context.sent;\n                _context.next = 9;\n                return cache.keys();\n\n              case 9:\n                alreadyCachedRequests = _context.sent;\n                existingCacheKeys = new Set(alreadyCachedRequests.map(function (request) {\n                  return request.url;\n                }));\n                _iterator2 = _createForOfIteratorHelper(this._urlsToCacheKeys);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _step2$value = _slicedToArray(_step2.value, 2), url = _step2$value[0], cacheKey = _step2$value[1];\n\n                    if (existingCacheKeys.has(cacheKey)) {\n                      alreadyPrecached.push(url);\n                    } else {\n                      toBePrecached.push({\n                        cacheKey: cacheKey,\n                        url: url\n                      });\n                    }\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                precacheRequests = toBePrecached.map(function (_ref2) {\n                  var cacheKey = _ref2.cacheKey,\n                      url = _ref2.url;\n\n                  var integrity = _this._cacheKeysToIntegrities.get(cacheKey);\n\n                  var cacheMode = _this._urlsToCacheModes.get(url);\n\n                  return _this._addURLToCache({\n                    cacheKey: cacheKey,\n                    cacheMode: cacheMode,\n                    event: event,\n                    integrity: integrity,\n                    plugins: plugins,\n                    url: url\n                  });\n                });\n                _context.next = 16;\n                return Promise.all(precacheRequests);\n\n              case 16:\n                updatedURLs = toBePrecached.map(function (item) {\n                  return item.url;\n                });\n\n                if (process.env.NODE_ENV !== 'production') {\n                  printInstallDetails(updatedURLs, alreadyPrecached);\n                }\n\n                return _context.abrupt(\"return\", {\n                  updatedURLs: updatedURLs,\n                  notUpdatedURLs: alreadyPrecached\n                });\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function install() {\n        return _install.apply(this, arguments);\n      }\n\n      return install;\n    }()\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n\n  }, {\n    key: \"activate\",\n    value: function () {\n      var _activate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var cache, currentlyCachedRequests, expectedCacheKeys, deletedURLs, _iterator3, _step3, request;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return self.caches.open(this._cacheName);\n\n              case 2:\n                cache = _context2.sent;\n                _context2.next = 5;\n                return cache.keys();\n\n              case 5:\n                currentlyCachedRequests = _context2.sent;\n                expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n                deletedURLs = [];\n                _iterator3 = _createForOfIteratorHelper(currentlyCachedRequests);\n                _context2.prev = 9;\n\n                _iterator3.s();\n\n              case 11:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                request = _step3.value;\n\n                if (expectedCacheKeys.has(request.url)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                _context2.next = 16;\n                return cache.delete(request);\n\n              case 16:\n                deletedURLs.push(request.url);\n\n              case 17:\n                _context2.next = 11;\n                break;\n\n              case 19:\n                _context2.next = 24;\n                break;\n\n              case 21:\n                _context2.prev = 21;\n                _context2.t0 = _context2[\"catch\"](9);\n\n                _iterator3.e(_context2.t0);\n\n              case 24:\n                _context2.prev = 24;\n\n                _iterator3.f();\n\n                return _context2.finish(24);\n\n              case 27:\n                if (process.env.NODE_ENV !== 'production') {\n                  printCleanupDetails(deletedURLs);\n                }\n\n                return _context2.abrupt(\"return\", {\n                  deletedURLs: deletedURLs\n                });\n\n              case 29:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[9, 21, 24, 27]]);\n      }));\n\n      function activate() {\n        return _activate.apply(this, arguments);\n      }\n\n      return activate;\n    }()\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n\n  }, {\n    key: \"_addURLToCache\",\n    value: function () {\n      var _addURLToCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n        var cacheKey, url, cacheMode, event, plugins, integrity, request, response, cacheWillUpdatePlugin, _iterator4, _step4, plugin, isValidResponse;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                cacheKey = _ref3.cacheKey, url = _ref3.url, cacheMode = _ref3.cacheMode, event = _ref3.event, plugins = _ref3.plugins, integrity = _ref3.integrity;\n                request = new Request(url, {\n                  integrity: integrity,\n                  cache: cacheMode,\n                  credentials: 'same-origin'\n                });\n                _context3.next = 4;\n                return fetchWrapper.fetch({\n                  event: event,\n                  plugins: plugins,\n                  request: request\n                });\n\n              case 4:\n                response = _context3.sent;\n                _iterator4 = _createForOfIteratorHelper(plugins || []);\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    plugin = _step4.value;\n\n                    if ('cacheWillUpdate' in plugin) {\n                      cacheWillUpdatePlugin = plugin;\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n\n                if (!cacheWillUpdatePlugin) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                _context3.next = 10;\n                return cacheWillUpdatePlugin.cacheWillUpdate({\n                  event: event,\n                  request: request,\n                  response: response\n                });\n\n              case 10:\n                _context3.t0 = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 13:\n                _context3.t0 = // Otherwise, default to considering any response status under 400 valid.\n                // This includes, by default, considering opaque responses valid.\n                response.status < 400;\n\n              case 14:\n                isValidResponse = _context3.t0;\n\n                if (isValidResponse) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                throw new WorkboxError('bad-precaching-response', {\n                  url: url,\n                  status: response.status\n                });\n\n              case 17:\n                if (!response.redirected) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                _context3.next = 20;\n                return copyResponse(response);\n\n              case 20:\n                response = _context3.sent;\n\n              case 21:\n                _context3.next = 23;\n                return cacheWrapper.put({\n                  event: event,\n                  plugins: plugins,\n                  response: response,\n                  // `request` already uses `url`. We may be able to reuse it.\n                  request: cacheKey === url ? request : new Request(cacheKey),\n                  cacheName: this._cacheName,\n                  matchOptions: {\n                    ignoreSearch: true\n                  }\n                });\n\n              case 23:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _addURLToCache(_x) {\n        return _addURLToCache2.apply(this, arguments);\n      }\n\n      return _addURLToCache;\n    }()\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n\n  }, {\n    key: \"getURLsToCacheKeys\",\n    value: function getURLsToCacheKeys() {\n      return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n\n  }, {\n    key: \"getCachedURLs\",\n    value: function getCachedURLs() {\n      return _toConsumableArray(this._urlsToCacheKeys.keys());\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n\n  }, {\n    key: \"getCacheKeyForURL\",\n    value: function getCacheKeyForURL(url) {\n      var urlObject = new URL(url, location.href);\n      return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n\n  }, {\n    key: \"matchPrecache\",\n    value: function () {\n      var _matchPrecache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(request) {\n        var url, cacheKey, cache;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                url = request instanceof Request ? request.url : request;\n                cacheKey = this.getCacheKeyForURL(url);\n\n                if (!cacheKey) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 5;\n                return self.caches.open(this._cacheName);\n\n              case 5:\n                cache = _context4.sent;\n                return _context4.abrupt(\"return\", cache.match(cacheKey));\n\n              case 7:\n                return _context4.abrupt(\"return\", undefined);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function matchPrecache(_x2) {\n        return _matchPrecache.apply(this, arguments);\n      }\n\n      return matchPrecache;\n    }()\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n\n  }, {\n    key: \"createHandler\",\n    value: function createHandler() {\n      var _this2 = this;\n\n      var fallbackToNetwork = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref4) {\n          var request, response;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  request = _ref4.request;\n                  _context5.prev = 1;\n                  _context5.next = 4;\n                  return _this2.matchPrecache(request);\n\n                case 4:\n                  response = _context5.sent;\n\n                  if (!response) {\n                    _context5.next = 7;\n                    break;\n                  }\n\n                  return _context5.abrupt(\"return\", response);\n\n                case 7:\n                  throw new WorkboxError('missing-precache-entry', {\n                    cacheName: _this2._cacheName,\n                    url: request instanceof Request ? request.url : request\n                  });\n\n                case 10:\n                  _context5.prev = 10;\n                  _context5.t0 = _context5[\"catch\"](1);\n\n                  if (!fallbackToNetwork) {\n                    _context5.next = 15;\n                    break;\n                  }\n\n                  if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(\"Unable to respond with precached response. \" + \"Falling back to network.\", _context5.t0);\n                  }\n\n                  return _context5.abrupt(\"return\", fetch(request));\n\n                case 15:\n                  throw _context5.t0;\n\n                case 16:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, null, [[1, 10]]);\n        }));\n\n        return function (_x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n\n  }, {\n    key: \"createHandlerBoundToURL\",\n    value: function createHandlerBoundToURL(url) {\n      var fallbackToNetwork = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var cacheKey = this.getCacheKeyForURL(url);\n\n      if (!cacheKey) {\n        throw new WorkboxError('non-precached-url', {\n          url: url\n        });\n      }\n\n      var handler = this.createHandler(fallbackToNetwork);\n      var request = new Request(url);\n      return function () {\n        return handler({\n          request: request\n        });\n      };\n    }\n  }]);\n\n  return PrecacheController;\n}();\n\nexport { PrecacheController };","map":{"version":3,"sources":["/Users/tm/Documents/CODE/ION/STUDYPELAGO/node_modules/workbox-precaching/PrecacheController.js"],"names":["assert","cacheNames","cacheWrapper","fetchWrapper","logger","WorkboxError","copyResponse","createCacheKey","printCleanupDetails","printInstallDetails","PrecacheController","cacheName","_cacheName","getPrecacheName","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","entries","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","entry","push","revision","undefined","url","cacheKey","cacheMode","has","get","firstEntry","secondEntry","integrity","set","length","warningMessage","join","console","warn","event","plugins","toBePrecached","alreadyPrecached","self","caches","open","cache","keys","alreadyCachedRequests","existingCacheKeys","Set","map","request","precacheRequests","_addURLToCache","Promise","all","updatedURLs","item","notUpdatedURLs","currentlyCachedRequests","expectedCacheKeys","values","deletedURLs","delete","Request","credentials","fetch","response","plugin","cacheWillUpdatePlugin","cacheWillUpdate","status","isValidResponse","redirected","put","matchOptions","ignoreSearch","urlObject","URL","location","href","getCacheKeyForURL","match","fallbackToNetwork","matchPrecache","debug","handler","createHandler"],"mappings":"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","sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { cacheWrapper } from 'workbox-core/_private/cacheWrapper.js';\nimport { fetchWrapper } from 'workbox-core/_private/fetchWrapper.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {string} [cacheName] An optional name for the cache, to override\n     * the default precache name.\n     */\n    constructor(cacheName) {\n        this._cacheName = cacheNames.getPrecacheName(cacheName);\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {\n     * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n     * } entries Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = (typeof entry !== 'string' && entry.revision) ?\n                'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * @param {Object} options\n     * @param {Event} [options.event] The install event (if needed).\n     * @param {Array<Object>} [options.plugins] Plugins to be used for fetching\n     * and caching during install.\n     * @return {Promise<module:workbox-precaching.InstallResult>}\n     */\n    async install({ event, plugins } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (plugins) {\n                assert.isArray(plugins, {\n                    moduleName: 'workbox-precaching',\n                    className: 'PrecacheController',\n                    funcName: 'install',\n                    paramName: 'plugins',\n                });\n            }\n        }\n        const toBePrecached = [];\n        const alreadyPrecached = [];\n        const cache = await self.caches.open(this._cacheName);\n        const alreadyCachedRequests = await cache.keys();\n        const existingCacheKeys = new Set(alreadyCachedRequests.map((request) => request.url));\n        for (const [url, cacheKey] of this._urlsToCacheKeys) {\n            if (existingCacheKeys.has(cacheKey)) {\n                alreadyPrecached.push(url);\n            }\n            else {\n                toBePrecached.push({ cacheKey, url });\n            }\n        }\n        const precacheRequests = toBePrecached.map(({ cacheKey, url }) => {\n            const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n            const cacheMode = this._urlsToCacheModes.get(url);\n            return this._addURLToCache({\n                cacheKey,\n                cacheMode,\n                event,\n                integrity,\n                plugins,\n                url,\n            });\n        });\n        await Promise.all(precacheRequests);\n        const updatedURLs = toBePrecached.map((item) => item.url);\n        if (process.env.NODE_ENV !== 'production') {\n            printInstallDetails(updatedURLs, alreadyPrecached);\n        }\n        return {\n            updatedURLs,\n            notUpdatedURLs: alreadyPrecached,\n        };\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * @return {Promise<module:workbox-precaching.CleanupResult>}\n     */\n    async activate() {\n        const cache = await self.caches.open(this._cacheName);\n        const currentlyCachedRequests = await cache.keys();\n        const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n        const deletedURLs = [];\n        for (const request of currentlyCachedRequests) {\n            if (!expectedCacheKeys.has(request.url)) {\n                await cache.delete(request);\n                deletedURLs.push(request.url);\n            }\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            printCleanupDetails(deletedURLs);\n        }\n        return { deletedURLs };\n    }\n    /**\n     * Requests the entry and saves it to the cache if the response is valid.\n     * By default, any response with a status code of less than 400 (including\n     * opaque responses) is considered valid.\n     *\n     * If you need to use custom criteria to determine what's valid and what\n     * isn't, then pass in an item in `options.plugins` that implements the\n     * `cacheWillUpdate()` lifecycle event.\n     *\n     * @private\n     * @param {Object} options\n     * @param {string} options.cacheKey The string to use a cache key.\n     * @param {string} options.url The URL to fetch and cache.\n     * @param {string} [options.cacheMode] The cache mode for the network request.\n     * @param {Event} [options.event] The install event (if passed).\n     * @param {Array<Object>} [options.plugins] An array of plugins to apply to\n     * fetch and caching.\n     * @param {string} [options.integrity] The value to use for the `integrity`\n     * field when making the request.\n     */\n    async _addURLToCache({ cacheKey, url, cacheMode, event, plugins, integrity }) {\n        const request = new Request(url, {\n            integrity,\n            cache: cacheMode,\n            credentials: 'same-origin',\n        });\n        let response = await fetchWrapper.fetch({\n            event,\n            plugins,\n            request,\n        });\n        // Allow developers to override the default logic about what is and isn't\n        // valid by passing in a plugin implementing cacheWillUpdate(), e.g.\n        // a `CacheableResponsePlugin` instance.\n        let cacheWillUpdatePlugin;\n        for (const plugin of (plugins || [])) {\n            if ('cacheWillUpdate' in plugin) {\n                cacheWillUpdatePlugin = plugin;\n            }\n        }\n        const isValidResponse = cacheWillUpdatePlugin ?\n            // Use a callback if provided. It returns a truthy value if valid.\n            // NOTE: invoke the method on the plugin instance so the `this` context\n            // is correct.\n            await cacheWillUpdatePlugin.cacheWillUpdate({ event, request, response }) :\n            // Otherwise, default to considering any response status under 400 valid.\n            // This includes, by default, considering opaque responses valid.\n            response.status < 400;\n        // Consider this a failure, leading to the `install` handler failing, if\n        // we get back an invalid response.\n        if (!isValidResponse) {\n            throw new WorkboxError('bad-precaching-response', {\n                url,\n                status: response.status,\n            });\n        }\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        if (response.redirected) {\n            response = await copyResponse(response);\n        }\n        await cacheWrapper.put({\n            event,\n            plugins,\n            response,\n            // `request` already uses `url`. We may be able to reuse it.\n            request: cacheKey === url ? request : new Request(cacheKey),\n            cacheName: this._cacheName,\n            matchOptions: {\n                ignoreSearch: true,\n            },\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * This acts as a drop-in replacement for [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this._cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that can be used within a\n     * {@link module:workbox-routing.Route} that will find a response for the\n     * incoming request against the precache.\n     *\n     * If for an unexpected reason there is a cache miss for the request,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandler(fallbackToNetwork = true) {\n        return async ({ request }) => {\n            try {\n                const response = await this.matchPrecache(request);\n                if (response) {\n                    return response;\n                }\n                // This shouldn't normally happen, but there are edge cases:\n                // https://github.com/GoogleChrome/workbox/issues/1441\n                throw new WorkboxError('missing-precache-entry', {\n                    cacheName: this._cacheName,\n                    url: request instanceof Request ? request.url : request,\n                });\n            }\n            catch (error) {\n                if (fallbackToNetwork) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.debug(`Unable to respond with precached response. ` +\n                            `Falling back to network.`, error);\n                    }\n                    return fetch(request);\n                }\n                throw error;\n            }\n        };\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * If for an unexpected reason there is a cache miss when looking up `url`,\n     * this will fall back to retrieving the `Response` via `fetch()` when\n     * `fallbackToNetwork` is `true`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n     * response from the network if there's a precache miss.\n     * @return {module:workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url, fallbackToNetwork = true) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        const handler = this.createHandler(fallbackToNetwork);\n        const request = new Request(url);\n        return () => handler({ request });\n    }\n}\nexport { PrecacheController };\n"]},"metadata":{},"sourceType":"module"}